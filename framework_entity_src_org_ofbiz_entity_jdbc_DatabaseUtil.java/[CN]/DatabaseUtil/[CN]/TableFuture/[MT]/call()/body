{
  String entMessage="(" + timer.timeSinceLast() + "ms) Checking #"+ curEnt+ "/"+ totalEnt+ " Entity "+ entity.getEntityName()+ " with table "+ entity.getTableName(datasourceInfo);
  Debug.logVerbose(entMessage,module);
  if (messages != null)   messages.add(entMessage);
  if (tableNames.contains(entity.getTableName(datasourceInfo))) {
    tableNames.remove(entity.getTableName(datasourceInfo));
    if (colInfo != null) {
      Map<String,ModelField> fieldColNames=FastMap.newInstance();
      Iterator<ModelField> fieldIter=entity.getFieldsIterator();
      while (fieldIter.hasNext()) {
        ModelField field=fieldIter.next();
        fieldColNames.put(field.getColName(),field);
      }
      Map<String,ColumnCheckInfo> colMap=colInfo.get(entity.getTableName(datasourceInfo));
      if (colMap != null) {
        for (        ColumnCheckInfo ccInfo : colMap.values()) {
          if (fieldColNames.containsKey(ccInfo.columnName)) {
            ModelField field=null;
            field=fieldColNames.remove(ccInfo.columnName);
            ModelFieldType modelFieldType=modelFieldTypeReader.getModelFieldType(field.getType());
            if (modelFieldType != null) {
              String fullTypeStr=modelFieldType.getSqlType();
              String typeName;
              int columnSize=-1;
              int decimalDigits=-1;
              int openParen=fullTypeStr.indexOf('(');
              int closeParen=fullTypeStr.indexOf(')');
              int comma=fullTypeStr.indexOf(',');
              if (openParen > 0 && closeParen > 0 && closeParen > openParen) {
                typeName=fullTypeStr.substring(0,openParen);
                if (comma > 0 && comma > openParen && comma < closeParen) {
                  String csStr=fullTypeStr.substring(openParen + 1,comma);
                  try {
                    columnSize=Integer.parseInt(csStr);
                  }
 catch (                  NumberFormatException e) {
                    Debug.logError(e,module);
                  }
                  String ddStr=fullTypeStr.substring(comma + 1,closeParen);
                  try {
                    decimalDigits=Integer.parseInt(ddStr);
                  }
 catch (                  NumberFormatException e) {
                    Debug.logError(e,module);
                  }
                }
 else {
                  String csStr=fullTypeStr.substring(openParen + 1,closeParen);
                  try {
                    columnSize=Integer.parseInt(csStr);
                  }
 catch (                  NumberFormatException e) {
                    Debug.logError(e,module);
                  }
                }
              }
 else {
                typeName=fullTypeStr;
              }
              if (UtilValidate.isNotEmpty(modelFieldType.getSqlTypeAlias())) {
                typeName=modelFieldType.getSqlTypeAlias();
              }
              if (!ccInfo.typeName.equalsIgnoreCase(typeName)) {
                String message="WARNING: Column [" + ccInfo.columnName + "] of table ["+ entity.getTableName(datasourceInfo)+ "] of entity ["+ entity.getEntityName()+ "] is of type ["+ ccInfo.typeName+ "] in the database, but is defined as type ["+ typeName+ "] in the entity definition.";
                Debug.logError(message,module);
                if (messages != null)                 messages.add(message);
              }
              if (columnSize != -1 && ccInfo.columnSize != -1 && columnSize != ccInfo.columnSize && (columnSize * 3) != ccInfo.columnSize) {
                String message="WARNING: Column [" + ccInfo.columnName + "] of table ["+ entity.getTableName(datasourceInfo)+ "] of entity ["+ entity.getEntityName()+ "] has a column size of ["+ ccInfo.columnSize+ "] in the database, but is defined to have a column size of ["+ columnSize+ "] in the entity definition.";
                Debug.logWarning(message,module);
                if (messages != null)                 messages.add(message);
                if (columnSize > ccInfo.columnSize && colWrongSize != null) {
                  colWrongSize.add(entity.getEntityName() + "." + field.getName());
                }
              }
              if (decimalDigits != -1 && decimalDigits != ccInfo.decimalDigits) {
                String message="WARNING: Column [" + ccInfo.columnName + "] of table ["+ entity.getTableName(datasourceInfo)+ "] of entity ["+ entity.getEntityName()+ "] has a decimalDigits of ["+ ccInfo.decimalDigits+ "] in the database, but is defined to have a decimalDigits of ["+ decimalDigits+ "] in the entity definition.";
                Debug.logWarning(message,module);
                if (messages != null)                 messages.add(message);
              }
              if (checkPks && ccInfo.isPk && !field.getIsPk()) {
                String message="WARNING: Column [" + ccInfo.columnName + "] of table ["+ entity.getTableName(datasourceInfo)+ "] of entity ["+ entity.getEntityName()+ "] IS a primary key in the database, but IS NOT a primary key in the entity definition. The primary key for this table needs to be re-created or modified so that this column is NOT part of the primary key.";
                Debug.logError(message,module);
                if (messages != null)                 messages.add(message);
              }
              if (checkPks && !ccInfo.isPk && field.getIsPk()) {
                String message="WARNING: Column [" + ccInfo.columnName + "] of table ["+ entity.getTableName(datasourceInfo)+ "] of entity ["+ entity.getEntityName()+ "] IS NOT a primary key in the database, but IS a primary key in the entity definition. The primary key for this table needs to be re-created or modified to add this column to the primary key. Note that data may need to be added first as a primary key column cannot have an null values.";
                Debug.logError(message,module);
                if (messages != null)                 messages.add(message);
              }
            }
 else {
              String message="Column [" + ccInfo.columnName + "] of table ["+ entity.getTableName(datasourceInfo)+ "] of entity ["+ entity.getEntityName()+ "] has a field type name of ["+ field.getType()+ "] which is not found in the field type definitions";
              Debug.logError(message,module);
              if (messages != null)               messages.add(message);
            }
          }
 else {
            String message="Column [" + ccInfo.columnName + "] of table ["+ entity.getTableName(datasourceInfo)+ "] of entity ["+ entity.getEntityName()+ "] exists in the database but has no corresponding field"+ ((checkPks && ccInfo.isPk) ? " (and it is a PRIMARY KEY COLUMN)" : "");
            Debug.logWarning(message,module);
            if (messages != null)             messages.add(message);
          }
        }
        if (colMap.size() != entity.getFieldsSize()) {
          String message="Entity [" + entity.getEntityName() + "] has "+ entity.getFieldsSize()+ " fields but table ["+ entity.getTableName(datasourceInfo)+ "] has "+ colMap.size()+ " columns.";
          Debug.logWarning(message,module);
          if (messages != null)           messages.add(message);
        }
      }
      for (      String colName : fieldColNames.keySet()) {
        ModelField field=(ModelField)fieldColNames.get(colName);
        String message="Field [" + field.getName() + "] of entity ["+ entity.getEntityName()+ "] is missing its corresponding column ["+ field.getColName()+ "]"+ (field.getIsPk() ? " (and it is a PRIMARY KEY FIELD)" : "");
        Debug.logWarning(message,module);
        if (messages != null)         messages.add(message);
        if (addMissing) {
          String errMsg=addColumn(entity,field);
          if (UtilValidate.isNotEmpty(errMsg)) {
            message="Could not add column [" + field.getColName() + "] to table ["+ entity.getTableName(datasourceInfo)+ "]: "+ errMsg;
            Debug.logError(message,module);
            if (messages != null)             messages.add(message);
          }
 else {
            message="Added column [" + field.getColName() + "] to table ["+ entity.getTableName(datasourceInfo)+ "]"+ (field.getIsPk() ? " (NOTE: this is a PRIMARY KEY FIELD, but the primary key was not updated automatically (not considered a safe operation), be sure to fill in any needed data and re-create the primary key)" : "");
            Debug.logImportant(message,module);
            if (messages != null)             messages.add(message);
          }
        }
      }
    }
  }
 else {
    String message="Entity [" + entity.getEntityName() + "] has no table in the database";
    Debug.logWarning(message,module);
    if (messages != null)     messages.add(message);
    if (addMissing) {
      String errMsg=createTable(entity,modelEntities,false);
      if (UtilValidate.isNotEmpty(errMsg)) {
        message="Could not create table [" + entity.getTableName(datasourceInfo) + "]: "+ errMsg;
        Debug.logError(message,module);
        if (messages != null)         messages.add(message);
      }
 else {
        entityAdded=true;
        message="Created table [" + entity.getTableName(datasourceInfo) + "]";
        Debug.logImportant(message,module);
        if (messages != null)         messages.add(message);
      }
    }
  }
  return this;
}
