{
  if (isLegacy) {
    throw new RuntimeException("Cannot run checkDb on a legacy database connection; configure a database helper (entityengine.xml)");
  }
  UtilTimer timer=new UtilTimer();
  timer.timerString("Start - Before Get Database Meta Data");
  SortedSet<String> tableNames=this.getTableNames(messages);
  TreeSet<String> fkTableNames=tableNames == null ? null : new TreeSet<String>(tableNames);
  TreeSet<String> indexTableNames=tableNames == null ? null : new TreeSet<String>(tableNames);
  if (tableNames == null) {
    String message="Could not get table name information from the database, aborting.";
    if (messages != null)     messages.add(message);
    Debug.logError(message,module);
    return;
  }
  timer.timerString("After Get All Table Names");
  Map<String,Map<String,ColumnCheckInfo>> colInfo=this.getColumnInfo(tableNames,checkPks,messages);
  if (colInfo == null) {
    String message="Could not get column information from the database, aborting.";
    if (messages != null)     messages.add(message);
    Debug.logError(message,module);
    return;
  }
  timer.timerString("After Get All Column Info");
  timer.timerString("Before Individual Table/Column Check");
  ArrayList<ModelEntity> modelEntityList=new ArrayList<ModelEntity>(modelEntities.values());
  Collections.sort(modelEntityList);
  int curEnt=0;
  int totalEnt=modelEntityList.size();
  List<ModelEntity> entitiesAdded=FastList.newInstance();
  List<Future<TableFuture>> tableFutureFutures=FastList.newInstance();
  ScheduledExecutorService threadPool=ExecutionPool.getNewOptimalExecutor("Databaseutil");
  for (  ModelEntity entity : modelEntityList) {
    curEnt++;
    if (entity instanceof ModelViewEntity) {
      String entMessage="(" + timer.timeSinceLast() + "ms) NOT Checking #"+ curEnt+ "/"+ totalEnt+ " View Entity "+ entity.getEntityName();
      Debug.logVerbose(entMessage,module);
      if (messages != null)       messages.add(entMessage);
      continue;
    }
    tableFutureFutures.add(threadPool.submit(new TableFuture(modelEntities,timer,tableNames,colInfo,curEnt,totalEnt,entity,checkPks,addMissing)));
  }
  for (  TableFuture tableFuture : getAllFutures(tableFutureFutures)) {
    tableFuture.updateData(messages,entitiesAdded);
  }
  timer.timerString("After Individual Table/Column Check");
  for (  String tableName : tableNames) {
    String message="Table named [" + tableName + "] exists in the database but has no corresponding entity";
    Debug.logWarning(message,module);
    if (messages != null)     messages.add(message);
  }
  if (datasourceInfo.useFkIndices) {
    List<Future<ForeignKeyIndexFuture>> fkIndicesFutureFutures=FastList.newInstance();
    AtomicInteger totalFkIndices=new AtomicInteger();
    for (    ModelEntity curEntity : entitiesAdded) {
      if (curEntity.getRelationsOneSize() > 0) {
        fkIndicesFutureFutures.add(threadPool.submit(new ForeignKeyIndexFuture(totalFkIndices,curEntity,datasourceInfo.constraintNameClipLength)));
      }
    }
    for (    ForeignKeyIndexFuture fkIndicesFuture : getAllFutures(fkIndicesFutureFutures)) {
      fkIndicesFuture.updateData(messages);
    }
    if (totalFkIndices.get() > 0)     Debug.logImportant("==== TOTAL Foreign Key Indices Created: " + totalFkIndices.get(),module);
  }
  if (datasourceInfo.useFks) {
    int totalFks=0;
    for (    ModelEntity curEntity : entitiesAdded) {
      totalFks+=this.createForeignKeys(curEntity,modelEntities,datasourceInfo.constraintNameClipLength,datasourceInfo.fkStyle,datasourceInfo.useFkInitiallyDeferred,messages);
    }
    if (totalFks > 0)     Debug.logImportant("==== TOTAL Foreign Keys Created: " + totalFks,module);
  }
  if (datasourceInfo.useIndices) {
    List<Future<DeclaredIndexFuture>> disFutureFutures=FastList.newInstance();
    AtomicInteger totalDis=new AtomicInteger();
    for (    ModelEntity curEntity : entitiesAdded) {
      if (curEntity.getIndexesSize() > 0) {
        disFutureFutures.add(threadPool.submit(new DeclaredIndexFuture(totalDis,curEntity)));
      }
    }
    for (    DeclaredIndexFuture disFuture : getAllFutures(disFutureFutures)) {
      disFuture.updateData(messages);
    }
    if (totalDis.get() > 0)     Debug.logImportant("==== TOTAL Declared Indices Created: " + totalDis.get(),module);
  }
  if (checkFks) {
    int numFksCreated=0;
    Map<String,Map<String,ReferenceCheckInfo>> refTableInfoMap=this.getReferenceInfo(fkTableNames,messages);
    if (refTableInfoMap == null) {
      if (Debug.verboseOn())       Debug.logVerbose("Ref Table Info Map is null",module);
    }
 else {
      for (      ModelEntity entity : modelEntityList) {
        String entityName=entity.getEntityName();
        if (entity instanceof ModelViewEntity) {
          String entMessage="NOT Checking View Entity " + entity.getEntityName();
          Debug.logVerbose(entMessage,module);
          if (messages != null) {
            messages.add(entMessage);
          }
          continue;
        }
        Map<String,ReferenceCheckInfo> rcInfoMap=refTableInfoMap.get(entity.getTableName(datasourceInfo));
        Iterator<ModelRelation> relations=entity.getRelationsIterator();
        boolean createdConstraints=false;
        while (relations.hasNext()) {
          ModelRelation modelRelation=relations.next();
          if (!"one".equals(modelRelation.getType())) {
            continue;
          }
          ModelEntity relModelEntity=modelEntities.get(modelRelation.getRelEntityName());
          if (relModelEntity == null) {
            Debug.logError("No such relation: " + entity.getEntityName() + " -> "+ modelRelation.getRelEntityName(),module);
            continue;
          }
          String relConstraintName=makeFkConstraintName(modelRelation,datasourceInfo.constraintNameClipLength);
          ReferenceCheckInfo rcInfo=null;
          if (rcInfoMap != null) {
            rcInfo=rcInfoMap.get(relConstraintName);
          }
          if (rcInfo != null) {
            rcInfoMap.remove(relConstraintName);
          }
 else {
            String noFkMessage="No Foreign Key Constraint [" + relConstraintName + "] found for entity ["+ entityName+ "]";
            if (messages != null)             messages.add(noFkMessage);
            if (Debug.infoOn())             Debug.logInfo(noFkMessage,module);
            if (addMissing) {
              String errMsg=createForeignKey(entity,modelRelation,relModelEntity,datasourceInfo.constraintNameClipLength,datasourceInfo.fkStyle,datasourceInfo.useFkInitiallyDeferred);
              if (UtilValidate.isNotEmpty(errMsg)) {
                String message="Could not create foreign key " + relConstraintName + " for entity ["+ entity.getEntityName()+ "]: "+ errMsg;
                Debug.logError(message,module);
                if (messages != null)                 messages.add(message);
              }
 else {
                String message="Created foreign key " + relConstraintName + " for entity ["+ entity.getEntityName()+ "]";
                Debug.logVerbose(message,module);
                if (messages != null)                 messages.add(message);
                createdConstraints=true;
                numFksCreated++;
              }
            }
          }
        }
        if (createdConstraints) {
          String message="Created foreign key(s) for entity [" + entity.getEntityName() + "]";
          Debug.logImportant(message,module);
          if (messages != null)           messages.add(message);
        }
        if (rcInfoMap != null) {
          for (          String rcKeyLeft : rcInfoMap.keySet()) {
            String message="Unknown Foreign Key Constraint " + rcKeyLeft + " found in table "+ entity.getTableName(datasourceInfo);
            Debug.logImportant(message,module);
            if (messages != null)             messages.add(message);
          }
        }
      }
    }
    if (Debug.infoOn())     Debug.logInfo("Created " + numFksCreated + " fk refs",module);
  }
  if (checkFkIdx || datasourceInfo.checkIndicesOnStart) {
    int numIndicesCreated=0;
    boolean needsUpperCase[]=new boolean[1];
    Map<String,Set<String>> tableIndexListMap=this.getIndexInfo(indexTableNames,messages,needsUpperCase);
    if (tableIndexListMap == null) {
      if (Debug.verboseOn())       Debug.logVerbose("Ref Table Info Map is null",module);
    }
 else {
      for (      ModelEntity entity : modelEntityList) {
        String entityName=entity.getEntityName();
        if (entity instanceof ModelViewEntity) {
          String entMessage="NOT Checking View Entity " + entity.getEntityName();
          Debug.logVerbose(entMessage,module);
          if (messages != null)           messages.add(entMessage);
          continue;
        }
        Set<String> tableIndexList=tableIndexListMap.get(entity.getTableName(datasourceInfo));
        if (tableIndexList == null) {
          if (checkFkIdx) {
            this.createForeignKeyIndices(entity,datasourceInfo.constraintNameClipLength,messages);
          }
          if (datasourceInfo.checkIndicesOnStart) {
            this.createDeclaredIndices(entity,messages);
          }
          continue;
        }
        boolean createdConstraints=false;
        Iterator<ModelRelation> relations=entity.getRelationsIterator();
        while (relations.hasNext()) {
          ModelRelation modelRelation=relations.next();
          if (!"one".equals(modelRelation.getType())) {
            continue;
          }
          String relConstraintName=makeFkConstraintName(modelRelation,datasourceInfo.constraintNameClipLength);
          if (tableIndexList.contains(relConstraintName)) {
            tableIndexList.remove(relConstraintName);
          }
 else {
            if (checkFkIdx) {
              String noIdxMessage="No Index [" + relConstraintName + "] found for entity ["+ entityName+ "]";
              if (messages != null)               messages.add(noIdxMessage);
              if (Debug.infoOn())               Debug.logInfo(noIdxMessage,module);
              if (addMissing) {
                String errMsg=createForeignKeyIndex(entity,modelRelation,datasourceInfo.constraintNameClipLength);
                if (UtilValidate.isNotEmpty(errMsg)) {
                  String message="Could not create foreign key index " + relConstraintName + " for entity ["+ entity.getEntityName()+ "]: "+ errMsg;
                  Debug.logError(message,module);
                  if (messages != null)                   messages.add(message);
                }
 else {
                  String message="Created foreign key index " + relConstraintName + " for entity ["+ entity.getEntityName()+ "]";
                  Debug.logVerbose(message,module);
                  if (messages != null)                   messages.add(message);
                  createdConstraints=true;
                  numIndicesCreated++;
                }
              }
            }
          }
        }
        if (createdConstraints) {
          String message="Created foreign key index/indices for entity [" + entity.getEntityName() + "]";
          Debug.logImportant(message,module);
          if (messages != null)           messages.add(message);
        }
        boolean createdIndexes=false;
        Iterator<ModelIndex> indexes=entity.getIndexesIterator();
        while (indexes.hasNext()) {
          ModelIndex modelIndex=indexes.next();
          String relIndexName=makeIndexName(modelIndex,datasourceInfo.constraintNameClipLength);
          String checkIndexName=needsUpperCase[0] ? relIndexName.toUpperCase() : relIndexName;
          if (tableIndexList.contains(checkIndexName)) {
            tableIndexList.remove(checkIndexName);
          }
 else {
            if (datasourceInfo.checkIndicesOnStart) {
              String noIdxMessage="No Index [" + relIndexName + "] found for entity ["+ entityName+ "]";
              if (messages != null)               messages.add(noIdxMessage);
              if (Debug.infoOn())               Debug.logInfo(noIdxMessage,module);
              if (addMissing) {
                String errMsg=createDeclaredIndex(entity,modelIndex);
                if (UtilValidate.isNotEmpty(errMsg)) {
                  String message="Could not create index " + relIndexName + " for entity ["+ entity.getEntityName()+ "]: "+ errMsg;
                  Debug.logError(message,module);
                  if (messages != null)                   messages.add(message);
                }
 else {
                  String message="Created index " + relIndexName + " for entity ["+ entity.getEntityName()+ "]";
                  Debug.logVerbose(message,module);
                  if (messages != null)                   messages.add(message);
                  createdIndexes=true;
                  numIndicesCreated++;
                }
              }
            }
          }
        }
        if (createdIndexes) {
          String message="Created declared index/indices for entity [" + entity.getEntityName() + "]";
          Debug.logImportant(message,module);
          if (messages != null)           messages.add(message);
        }
        if (tableIndexList != null) {
          for (          String indexLeft : tableIndexList) {
            String message="Unknown Index " + indexLeft + " found in table "+ entity.getTableName(datasourceInfo);
            Debug.logImportant(message,module);
            if (messages != null)             messages.add(message);
          }
        }
      }
    }
    if (numIndicesCreated > 0 && Debug.infoOn())     Debug.logInfo("Created " + numIndicesCreated + " indices",module);
  }
  timer.timerString("Finished Checking Entity Database");
}
