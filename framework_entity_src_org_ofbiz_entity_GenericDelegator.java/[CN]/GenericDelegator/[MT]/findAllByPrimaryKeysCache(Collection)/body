{
  boolean beganTransaction=false;
  try {
    if (alwaysUseTransaction) {
      beganTransaction=TransactionUtil.begin();
    }
    if (primaryKeys == null)     return null;
    List results=FastList.newInstance();
    Map pksPerHelper=FastMap.newInstance();
    Iterator pkiter=primaryKeys.iterator();
    while (pkiter.hasNext()) {
      GenericPK curPK=(GenericPK)pkiter.next();
      GenericValue value=this.getFromPrimaryKeyCache(curPK);
      if (value != null) {
        results.add(value);
      }
 else {
        String helperName=this.getEntityHelperName(curPK.getEntityName());
        List pks=(List)pksPerHelper.get(helperName);
        if (pks == null) {
          pks=FastList.newInstance();
          pksPerHelper.put(helperName,pks);
        }
        pks.add(curPK);
      }
    }
    Iterator helperIter=pksPerHelper.entrySet().iterator();
    while (helperIter.hasNext()) {
      Map.Entry curEntry=(Map.Entry)helperIter.next();
      String helperName=(String)curEntry.getKey();
      GenericHelper helper=GenericHelperFactory.getHelper(helperName);
      List values=helper.findAllByPrimaryKeys((List)curEntry.getValue());
      this.putAllInPrimaryKeyCache(values);
      results.addAll(values);
    }
    this.decryptFields(results);
    return results;
  }
 catch (  GenericEntityException e) {
    String errMsg="Failure in findAllByPrimaryKeysCache operation, rolling back transaction";
    Debug.logError(e,errMsg,module);
    try {
      TransactionUtil.rollback(beganTransaction,errMsg,e);
    }
 catch (    GenericEntityException e2) {
      Debug.logError(e2,"[GenericDelegator] Could not rollback transaction: " + e2.toString(),module);
    }
    throw e;
  }
 finally {
    TransactionUtil.commit(beganTransaction);
  }
}
