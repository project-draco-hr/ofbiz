{
  boolean beganTransaction=false;
  try {
    if (alwaysUseTransaction) {
      beganTransaction=TransactionUtil.begin();
    }
    EntityEcaRuleRunner<?> ecaRunner=this.getEcaRuleRunner(primaryKey.getEntityName());
    ecaRunner.evalRules(EntityEcaHandler.EV_VALIDATE,EntityEcaHandler.OP_REMOVE,primaryKey,false);
    GenericHelper helper=getEntityHelper(primaryKey.getEntityName());
    if (doCacheClear) {
      ecaRunner.evalRules(EntityEcaHandler.EV_CACHE_CLEAR,EntityEcaHandler.OP_REMOVE,primaryKey,false);
      this.clearCacheLine(primaryKey);
    }
    ecaRunner.evalRules(EntityEcaHandler.EV_RUN,EntityEcaHandler.OP_REMOVE,primaryKey,false);
    if (primaryKey.getModelEntity().getHasFieldWithAuditLog()) {
      createEntityAuditLogAll(this.findOne(primaryKey.getEntityName(),primaryKey,false),true,true);
    }
    GenericValue removedEntity=null;
    if (testMode) {
      removedEntity=this.findOne(primaryKey.entityName,primaryKey,false);
    }
    int num=helper.removeByPrimaryKey(primaryKey);
    this.saveEntitySyncRemoveInfo(primaryKey);
    if (testMode) {
      storeForTestRollback(new TestOperation(OperationType.DELETE,removedEntity));
    }
    ecaRunner.evalRules(EntityEcaHandler.EV_RETURN,EntityEcaHandler.OP_REMOVE,primaryKey,false);
    return num;
  }
 catch (  GenericEntityException e) {
    String errMsg="Failure in removeByPrimaryKey operation for entity [" + primaryKey.getEntityName() + "]: "+ e.toString()+ ". Rolling back transaction.";
    Debug.logError(e,errMsg,module);
    try {
      TransactionUtil.rollback(beganTransaction,errMsg,e);
    }
 catch (    GenericEntityException e2) {
      Debug.logError(e2,"[GenericDelegator] Could not rollback transaction: " + e2.toString(),module);
    }
    throw e;
  }
 finally {
    TransactionUtil.commit(beganTransaction);
  }
}
