{
  boolean beganTransaction=false;
  try {
    if (alwaysUseTransaction) {
      beganTransaction=TransactionUtil.begin();
    }
    if (primaryKeys == null)     return null;
    List<GenericValue> results=FastList.newInstance();
    Map<String,List<GenericPK>> pksPerGroup=FastMap.newInstance();
    for (    GenericPK curPK : primaryKeys) {
      GenericValue value=this.getFromPrimaryKeyCache(curPK);
      if (value != null) {
        results.add(value);
      }
 else {
        String groupName=this.getEntityGroupName(curPK.getEntityName());
        List<GenericPK> pks=pksPerGroup.get(groupName);
        if (pks == null) {
          pks=FastList.newInstance();
          pksPerGroup.put(groupName,pks);
        }
        pks.add(curPK);
      }
    }
    for (    Map.Entry<String,List<GenericPK>> curEntry : pksPerGroup.entrySet()) {
      String groupName=curEntry.getKey();
      GenericHelper helper=GenericHelperFactory.getHelper(this.getGroupHelperInfo(groupName));
      List<GenericValue> values=helper.findAllByPrimaryKeys(curEntry.getValue());
      this.putAllInPrimaryKeyCache(values);
      results.addAll(values);
    }
    this.decryptFields(results);
    return results;
  }
 catch (  GenericEntityException e) {
    String errMsg="Failure in findAllByPrimaryKeysCache operation, rolling back transaction";
    Debug.logError(e,errMsg,module);
    try {
      TransactionUtil.rollback(beganTransaction,errMsg,e);
    }
 catch (    GenericEntityException e2) {
      Debug.logError(e2,"[GenericDelegator] Could not rollback transaction: " + e2.toString(),module);
    }
    throw e;
  }
 finally {
    TransactionUtil.commit(beganTransaction);
  }
}
