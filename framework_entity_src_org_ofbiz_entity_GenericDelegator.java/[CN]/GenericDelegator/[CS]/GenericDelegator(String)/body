{
  this.setDelegatorNames(delegatorFullName);
  if (UtilValidate.isNotEmpty(this.delegatorTenantId)) {
    Delegator baseDelegator=DelegatorFactory.getDelegator(this.delegatorBaseName);
    GenericValue tenant=baseDelegator.findOne("Tenant",true,"tenantId",this.delegatorTenantId);
    if (tenant == null) {
      throw new GenericEntityException("No Tenant record found for delegator [" + this.delegatorFullName + "] with tenantId ["+ this.delegatorTenantId+ "]");
    }
 else     if ("Y".equals(tenant.getString("disabled"))) {
      throw new GenericEntityException("No Tenant record found for delegator [" + this.delegatorFullName + "] with tenantId ["+ this.delegatorTenantId+ "]");
    }
  }
  this.modelReader=ModelReader.getModelReader(delegatorBaseName);
  this.modelGroupReader=ModelGroupReader.getModelGroupReader(delegatorBaseName);
  cache=new Cache(delegatorFullName);
  List<String> warningList=FastList.newInstance();
  Debug.logImportant("Doing entity definition check...",module);
  ModelEntityChecker.checkEntities(this,warningList);
  if (warningList.size() > 0) {
    Debug.logWarning("=-=-=-=-= Found " + warningList.size() + " warnings when checking the entity definitions:",module);
    for (    String warning : warningList) {
      Debug.logWarning(warning,module);
    }
  }
  Set<String> groupNames=getModelGroupReader().getGroupNames(delegatorBaseName);
  for (  String groupName : groupNames) {
    GenericHelperInfo helperInfo=this.getGroupHelperInfo(groupName);
    String helperBaseName=helperInfo.getHelperBaseName();
    if (Debug.infoOn())     Debug.logInfo("Delegator \"" + delegatorFullName + "\" initializing helper \""+ helperBaseName+ "\" for entity group \""+ groupName+ "\".",module);
    TreeSet<String> helpersDone=new TreeSet<String>();
    if (UtilValidate.isNotEmpty(helperInfo.getHelperFullName())) {
      if (helpersDone.contains(helperInfo.getHelperFullName())) {
        if (Debug.infoOn())         Debug.logInfo("Helper \"" + helperInfo.getHelperFullName() + "\" already initialized, not re-initializing.",module);
        continue;
      }
      helpersDone.add(helperInfo.getHelperFullName());
      ModelFieldTypeReader.getModelFieldTypeReader(helperBaseName);
      GenericHelper helper=GenericHelperFactory.getHelper(helperInfo);
      DatasourceInfo datasourceInfo=EntityConfigUtil.getDatasourceInfo(helperBaseName);
      if (datasourceInfo.checkOnStart) {
        if (Debug.infoOn())         Debug.logInfo("Doing database check as requested in entityengine.xml with addMissing=" + datasourceInfo.addMissingOnStart,module);
        try {
          helper.checkDataSource(this.getModelEntityMapByGroup(groupName),null,datasourceInfo.addMissingOnStart);
        }
 catch (        GenericEntityException e) {
          Debug.logWarning(e,e.getMessage(),module);
        }
      }
    }
  }
  this.crypto=new EntityCrypto(this);
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  if (getDelegatorInfo().useDistributedCacheClear) {
    String distributedCacheClearClassName=getDelegatorInfo().distributedCacheClearClassName;
    try {
      Class<?> dccClass=loader.loadClass(distributedCacheClearClassName);
      this.distributedCacheClear=(DistributedCacheClear)dccClass.newInstance();
      this.distributedCacheClear.setDelegator(this,getDelegatorInfo().distributedCacheClearUserLoginId);
    }
 catch (    ClassNotFoundException e) {
      Debug.logWarning(e,"DistributedCacheClear class with name " + distributedCacheClearClassName + " was not found, distributed cache clearing will be disabled",module);
    }
catch (    InstantiationException e) {
      Debug.logWarning(e,"DistributedCacheClear class with name " + distributedCacheClearClassName + " could not be instantiated, distributed cache clearing will be disabled",module);
    }
catch (    IllegalAccessException e) {
      Debug.logWarning(e,"DistributedCacheClear class with name " + distributedCacheClearClassName + " could not be accessed (illegal), distributed cache clearing will be disabled",module);
    }
catch (    ClassCastException e) {
      Debug.logWarning(e,"DistributedCacheClear class with name " + distributedCacheClearClassName + " does not implement the DistributedCacheClear interface, distributed cache clearing will be disabled",module);
    }
  }
 else {
    Debug.logInfo("Distributed Cache Clear System disabled for delegator [" + delegatorFullName + "]",module);
  }
}
