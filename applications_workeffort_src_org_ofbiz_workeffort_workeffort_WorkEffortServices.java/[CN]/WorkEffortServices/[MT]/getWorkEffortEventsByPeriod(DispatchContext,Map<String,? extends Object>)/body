{
  GenericDelegator delegator=ctx.getDelegator();
  Security security=ctx.getSecurity();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  Locale locale=(Locale)context.get("locale");
  TimeZone timeZone=(TimeZone)context.get("timeZone");
  Timestamp startDay=(Timestamp)context.get("start");
  Integer numPeriodsInteger=(Integer)context.get("numPeriods");
  String partyId=(String)context.get("partyId");
  Collection<String> partyIds=UtilGenerics.checkCollection(context.get("partyIds"));
  String facilityId=(String)context.get("facilityId");
  String fixedAssetId=(String)context.get("fixedAssetId");
  String workEffortTypeId=(String)context.get("workEffortTypeId");
  Boolean filterOutCanceledEvents=(Boolean)context.get("filterOutCanceledEvents");
  if (filterOutCanceledEvents == null) {
    filterOutCanceledEvents=Boolean.FALSE;
  }
  int maxConcurrentEntries=0;
  Integer periodTypeObject=(Integer)context.get("periodType");
  int periodType=0;
  if (periodTypeObject != null) {
    periodType=periodTypeObject.intValue();
  }
  int numPeriods=0;
  if (numPeriodsInteger != null) {
    numPeriods=numPeriodsInteger.intValue();
  }
  Timestamp startStamp=UtilDateTime.getDayStart(startDay,timeZone,locale);
  Timestamp endStamp=UtilDateTime.adjustTimestamp(startStamp,periodType,1,timeZone,locale);
  long periodLen=endStamp.getTime() - startStamp.getTime();
  endStamp=UtilDateTime.adjustTimestamp(startStamp,periodType,numPeriods,timeZone,locale);
  List<GenericValue> validWorkEfforts=null;
  Collection<String> partyIdsToUse=partyIds;
  if (partyIdsToUse == null) {
    partyIdsToUse=FastSet.newInstance();
  }
  if (UtilValidate.isNotEmpty(partyId)) {
    if (partyId.equals(userLogin.getString("partyId")) || security.hasEntityPermission("WORKEFFORTMGR","_VIEW",userLogin)) {
      partyIdsToUse.add(partyId);
    }
 else {
      return ServiceUtil.returnError("You do not have permission to view information for party with ID [" + partyId + "], you must be logged in as a user associated with this party, or have the WORKEFFORTMGR_VIEW or WORKEFFORTMGR_ADMIN permissions.");
    }
  }
 else {
    if (UtilValidate.isEmpty(facilityId) && UtilValidate.isEmpty(fixedAssetId)) {
      partyIdsToUse.add(userLogin.getString("partyId"));
    }
  }
  List<EntityCondition> entityExprList=UtilGenerics.checkList(context.get("entityExprList"));
  if (entityExprList == null) {
    entityExprList=getDefaultWorkEffortExprList(partyIds,facilityId,fixedAssetId,workEffortTypeId);
  }
  entityExprList.add(EntityCondition.makeCondition("estimatedCompletionDate",EntityOperator.GREATER_THAN_EQUAL_TO,startStamp));
  entityExprList.add(EntityCondition.makeCondition("estimatedStartDate",EntityOperator.LESS_THAN,endStamp));
  if (filterOutCanceledEvents.booleanValue()) {
    entityExprList.add(EntityCondition.makeCondition("currentStatusId",EntityOperator.NOT_EQUAL,"EVENT_CANCELLED"));
  }
  EntityConditionList<EntityCondition> ecl=EntityCondition.makeCondition(entityExprList);
  if (partyIdsToUse.size() > 0 || UtilValidate.isNotEmpty(facilityId) || UtilValidate.isNotEmpty(fixedAssetId)) {
    try {
      List<GenericValue> tempWorkEfforts=null;
      if (UtilValidate.isNotEmpty(partyIds)) {
        tempWorkEfforts=EntityUtil.filterByDate(delegator.findList("WorkEffortAndPartyAssign",ecl,null,UtilMisc.toList("estimatedStartDate"),null,false));
      }
 else {
        tempWorkEfforts=delegator.findList("WorkEffort",ecl,null,UtilMisc.toList("estimatedStartDate"),null,false);
      }
      Set<String> tempWeKeys=FastSet.newInstance();
      Iterator<GenericValue> tempWorkEffortIter=tempWorkEfforts.iterator();
      while (tempWorkEffortIter.hasNext()) {
        GenericValue tempWorkEffort=tempWorkEffortIter.next();
        String tempWorkEffortId=tempWorkEffort.getString("workEffortId");
        if (tempWeKeys.contains(tempWorkEffortId)) {
          tempWorkEffortIter.remove();
        }
 else {
          tempWeKeys.add(tempWorkEffortId);
        }
      }
      validWorkEfforts=UtilMisc.makeListWritable(tempWorkEfforts);
    }
 catch (    GenericEntityException e) {
      Debug.logWarning(e,module);
    }
  }
  List<Map<String,Object>> periods=FastList.newInstance();
  if (validWorkEfforts != null) {
    for (int i=0; i < numPeriods; i++) {
      Timestamp curPeriodStart=UtilDateTime.adjustTimestamp(startStamp,periodType,i,timeZone,locale);
      Timestamp curPeriodEnd=UtilDateTime.adjustTimestamp(curPeriodStart,periodType,1,timeZone,locale);
      List<Map<String,Object>> curWorkEfforts=FastList.newInstance();
      Map<String,Object> entry=FastMap.newInstance();
      for (int j=0; j < validWorkEfforts.size(); j++) {
        GenericValue workEffort=validWorkEfforts.get(j);
        Timestamp estimatedStartDate=workEffort.getTimestamp("estimatedStartDate");
        Timestamp estimatedCompletionDate=workEffort.getTimestamp("estimatedCompletionDate");
        if (estimatedStartDate == null || estimatedCompletionDate == null)         continue;
        if (estimatedStartDate.compareTo(curPeriodEnd) < 0 && estimatedCompletionDate.compareTo(curPeriodStart) > 0) {
          Map<String,Object> calEntry=FastMap.newInstance();
          calEntry.put("workEffort",workEffort);
          long length=((estimatedCompletionDate.after(endStamp) ? endStamp.getTime() : estimatedCompletionDate.getTime()) - (estimatedStartDate.before(startStamp) ? startStamp.getTime() : estimatedStartDate.getTime()));
          int periodSpan=(int)Math.ceil((double)length / periodLen);
          calEntry.put("periodSpan",Integer.valueOf(periodSpan));
          if (i == 0) {
            calEntry.put("startOfPeriod",Boolean.TRUE);
          }
 else {
            boolean startOfPeriod=((estimatedStartDate.getTime() - curPeriodStart.getTime()) >= 0);
            calEntry.put("startOfPeriod",Boolean.valueOf(startOfPeriod));
          }
          curWorkEfforts.add(calEntry);
        }
        if (estimatedStartDate.after(curPeriodEnd))         break;
        if (estimatedCompletionDate.before(curPeriodEnd)) {
          validWorkEfforts.remove(j);
          j--;
        }
      }
      int numEntries=curWorkEfforts.size();
      if (numEntries > maxConcurrentEntries) {
        maxConcurrentEntries=numEntries;
      }
      entry.put("start",curPeriodStart);
      entry.put("end",curPeriodEnd);
      entry.put("calendarEntries",curWorkEfforts);
      periods.add(entry);
    }
  }
  Map<String,Object> result=FastMap.newInstance();
  result.put("periods",periods);
  result.put("maxConcurrentEntries",Integer.valueOf(maxConcurrentEntries));
  return result;
}
