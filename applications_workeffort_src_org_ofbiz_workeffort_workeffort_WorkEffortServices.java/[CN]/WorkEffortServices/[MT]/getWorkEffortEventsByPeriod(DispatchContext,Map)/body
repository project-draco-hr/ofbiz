{
  GenericDelegator delegator=ctx.getDelegator();
  Security security=ctx.getSecurity();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  Locale locale=(Locale)context.get("locale");
  TimeZone timeZone=(TimeZone)context.get("timeZone");
  Timestamp startDay=(Timestamp)context.get("start");
  Integer numPeriodsInteger=(Integer)context.get("numPeriods");
  String partyId=(String)context.get("partyId");
  Collection partyIds=(Collection)context.get("partyIds");
  String facilityId=(String)context.get("facilityId");
  String fixedAssetId=(String)context.get("fixedAssetId");
  Boolean filterOutCanceledEvents=(Boolean)context.get("filterOutCanceledEvents");
  if (filterOutCanceledEvents == null) {
    filterOutCanceledEvents=Boolean.FALSE;
  }
  int maxConcurrentEntries=0;
  Integer periodTypeObject=(Integer)context.get("periodType");
  int periodType=0;
  if (periodTypeObject != null) {
    periodType=periodTypeObject.intValue();
  }
  int numPeriods=0;
  if (numPeriodsInteger != null) {
    numPeriods=numPeriodsInteger.intValue();
  }
  Timestamp startStamp=UtilDateTime.getDayStart(startDay,timeZone,locale);
  Timestamp endStamp=UtilDateTime.adjustTimestamp(startStamp,periodType,1,timeZone,locale);
  long periodLen=endStamp.getTime() - startStamp.getTime();
  endStamp=UtilDateTime.adjustTimestamp(startStamp,periodType,numPeriods,timeZone,locale);
  List validWorkEfforts=null;
  Collection partyIdsToUse=partyIds;
  if (partyIdsToUse == null) {
    partyIdsToUse=new HashSet();
  }
  if (UtilValidate.isNotEmpty(partyId)) {
    if (partyId.equals(userLogin.getString("partyId")) || security.hasEntityPermission("WORKEFFORTMGR","_VIEW",userLogin)) {
      partyIdsToUse.add(partyId);
    }
 else {
      return ServiceUtil.returnError("You do not have permission to view information for party with ID [" + partyId + "], you must be logged in as a user associated with this party, or have the WORKEFFORTMGR_VIEW or WORKEFFORTMGR_ADMIN permissions.");
    }
  }
 else {
    if (UtilValidate.isEmpty(facilityId) && UtilValidate.isEmpty(fixedAssetId)) {
      partyIdsToUse.add(userLogin.getString("partyId"));
    }
  }
  List entityExprList=(List)context.get("entityExprList");
  if (entityExprList == null) {
    entityExprList=getDefaultWorkEffortExprList(partyIds,facilityId,fixedAssetId);
  }
  entityExprList.add(new EntityExpr("estimatedCompletionDate",EntityOperator.GREATER_THAN_EQUAL_TO,startStamp));
  entityExprList.add(new EntityExpr("estimatedStartDate",EntityOperator.LESS_THAN,endStamp));
  if (filterOutCanceledEvents.booleanValue()) {
    entityExprList.add(new EntityExpr("currentStatusId",EntityOperator.NOT_EQUAL,"EVENT_CANCELLED"));
  }
  if (partyIdsToUse.size() > 0 || UtilValidate.isNotEmpty(facilityId) || UtilValidate.isNotEmpty(fixedAssetId)) {
    try {
      List tempWorkEfforts=null;
      if (partyIds != null && partyIds.size() > 0) {
        tempWorkEfforts=delegator.findByAnd("WorkEffortAndPartyAssign",entityExprList,UtilMisc.toList("estimatedStartDate"));
      }
 else {
        tempWorkEfforts=delegator.findByAnd("WorkEffort",entityExprList,UtilMisc.toList("estimatedStartDate"));
      }
      Set tempWeKeys=new HashSet();
      Iterator tempWorkEffortIter=tempWorkEfforts.iterator();
      while (tempWorkEffortIter.hasNext()) {
        GenericValue tempWorkEffort=(GenericValue)tempWorkEffortIter.next();
        String tempWorkEffortId=tempWorkEffort.getString("workEffortId");
        if (tempWeKeys.contains(tempWorkEffortId)) {
          tempWorkEffortIter.remove();
        }
 else {
          tempWeKeys.add(tempWorkEffortId);
        }
      }
      validWorkEfforts=new ArrayList(tempWorkEfforts);
    }
 catch (    GenericEntityException e) {
      Debug.logWarning(e,module);
    }
  }
  List periods=new ArrayList();
  if (validWorkEfforts != null) {
    for (int i=0; i < numPeriods; i++) {
      Timestamp curPeriodStart=UtilDateTime.adjustTimestamp(startStamp,periodType,i,timeZone,locale);
      Timestamp curPeriodEnd=UtilDateTime.adjustTimestamp(curPeriodStart,periodType,1,timeZone,locale);
      List curWorkEfforts=new ArrayList();
      Map entry=new HashMap();
      for (int j=0; j < validWorkEfforts.size(); j++) {
        GenericValue workEffort=(GenericValue)validWorkEfforts.get(j);
        Timestamp estimatedStartDate=workEffort.getTimestamp("estimatedStartDate");
        Timestamp estimatedCompletionDate=workEffort.getTimestamp("estimatedCompletionDate");
        if (estimatedStartDate == null || estimatedCompletionDate == null)         continue;
        if (estimatedStartDate.compareTo(curPeriodEnd) < 0 && estimatedCompletionDate.compareTo(curPeriodStart) > 0) {
          Map calEntry=new HashMap();
          calEntry.put("workEffort",workEffort);
          long length=((estimatedCompletionDate.after(endStamp) ? endStamp.getTime() : estimatedCompletionDate.getTime()) - (estimatedStartDate.before(startStamp) ? startStamp.getTime() : estimatedStartDate.getTime()));
          int periodSpan=(int)Math.ceil((double)length / periodLen);
          calEntry.put("periodSpan",new Integer(periodSpan));
          if (i == 0) {
            calEntry.put("startOfPeriod",Boolean.TRUE);
          }
 else {
            boolean startOfPeriod=((estimatedStartDate.getTime() - curPeriodStart.getTime()) >= 0);
            calEntry.put("startOfPeriod",new Boolean(startOfPeriod));
          }
          curWorkEfforts.add(calEntry);
        }
        if (estimatedStartDate.after(curPeriodEnd))         break;
        if (estimatedCompletionDate.before(curPeriodEnd)) {
          validWorkEfforts.remove(j);
          j--;
        }
      }
      int numEntries=curWorkEfforts.size();
      if (numEntries > maxConcurrentEntries) {
        maxConcurrentEntries=numEntries;
      }
      entry.put("start",curPeriodStart);
      entry.put("end",curPeriodEnd);
      entry.put("calendarEntries",curWorkEfforts);
      periods.add(entry);
    }
  }
  Map result=new HashMap();
  result.put("periods",periods);
  result.put("maxConcurrentEntries",new Integer(maxConcurrentEntries));
  return result;
}
