{
  Security security=ctx.getSecurity();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  Locale locale=(Locale)context.get("locale");
  Timestamp startDay=(Timestamp)context.get("start");
  Integer numPeriodsInteger=(Integer)context.get("numPeriods");
  String partyId=(String)context.get("partyId");
  Collection partyIds=(Collection)context.get("partyIds");
  String facilityId=(String)context.get("facilityId");
  String fixedAssetId=(String)context.get("fixedAssetId");
  Boolean filterOutCanceledEvents=(Boolean)context.get("filterOutCanceledEvents");
  if (filterOutCanceledEvents == null) {
    filterOutCanceledEvents=Boolean.FALSE;
  }
  int maxConcurrentEntries=0;
  TimeZone curTz=TimeZone.getDefault();
  Integer periodTypeObject=(Integer)context.get("periodType");
  int periodType=0;
  if (periodTypeObject != null) {
    periodType=periodTypeObject.intValue();
  }
  int numPeriods=0;
  if (numPeriodsInteger != null)   numPeriods=numPeriodsInteger.intValue();
  Timestamp startStamp=UtilDateTime.getDayStart(startDay,curTz,locale);
  Timestamp endStamp=UtilDateTime.adjustTimestamp(startStamp,periodType,1,curTz,locale);
  long periodLen=endStamp.getTime() - startStamp.getTime();
  endStamp=UtilDateTime.adjustTimestamp(startStamp,periodType,numPeriods,curTz,locale);
  List validWorkEfforts=null;
  Collection partyIdsToUse=partyIds;
  if (partyIdsToUse == null)   partyIdsToUse=new HashSet();
  if (UtilValidate.isNotEmpty(partyId)) {
    if (partyId.equals(userLogin.getString("partyId")) || security.hasEntityPermission("WORKEFFORTMGR","_VIEW",userLogin)) {
      partyIdsToUse.add(partyId);
    }
 else {
      return ServiceUtil.returnError("You do not have permission to view information for party with ID [" + partyId + "], you must be logged in as a user associated with this party, or have the WORKEFFORTMGR_VIEW or WORKEFFORTMGR_ADMIN permissions.");
    }
  }
 else {
    if (UtilValidate.isEmpty(facilityId) && UtilValidate.isEmpty(fixedAssetId)) {
      partyIdsToUse.add(userLogin.getString("partyId"));
    }
  }
  if (partyIdsToUse.size() > 0 || UtilValidate.isNotEmpty(facilityId) || UtilValidate.isNotEmpty(fixedAssetId)) {
    validWorkEfforts=getWorkEffortEvents(ctx,startStamp,endStamp,partyIdsToUse,facilityId,fixedAssetId);
  }
  if (filterOutCanceledEvents.booleanValue()) {
    validWorkEfforts=EntityUtil.filterOutByCondition(validWorkEfforts,new EntityExpr("currentStatusId",EntityOperator.EQUALS,"EVENT_CANCELLED"));
  }
  List periods=new ArrayList();
  if (validWorkEfforts != null) {
    for (int i=0; i < numPeriods; i++) {
      Timestamp curPeriodStart=UtilDateTime.adjustTimestamp(startStamp,periodType,i,curTz,locale);
      Timestamp curPeriodEnd=UtilDateTime.adjustTimestamp(curPeriodStart,periodType,1,curTz,locale);
      List curWorkEfforts=new ArrayList();
      Map entry=new HashMap();
      for (int j=0; j < validWorkEfforts.size(); j++) {
        GenericValue workEffort=(GenericValue)validWorkEfforts.get(j);
        Timestamp estimatedStartDate=workEffort.getTimestamp("estimatedStartDate");
        Timestamp estimatedCompletionDate=workEffort.getTimestamp("estimatedCompletionDate");
        if (estimatedStartDate == null || estimatedCompletionDate == null)         continue;
        if (estimatedStartDate.compareTo(curPeriodEnd) < 0 && estimatedCompletionDate.compareTo(curPeriodStart) > 0) {
          Map calEntry=new HashMap();
          calEntry.put("workEffort",workEffort);
          long length=((estimatedCompletionDate.after(endStamp) ? endStamp.getTime() : estimatedCompletionDate.getTime()) - (estimatedStartDate.before(startStamp) ? startStamp.getTime() : estimatedStartDate.getTime()));
          int periodSpan=(int)Math.ceil((double)length / periodLen);
          calEntry.put("periodSpan",new Integer(periodSpan));
          if (i == 0)           calEntry.put("startOfPeriod",Boolean.TRUE);
 else {
            boolean startOfPeriod=((estimatedStartDate.getTime() - curPeriodStart.getTime()) >= 0);
            calEntry.put("startOfPeriod",new Boolean(startOfPeriod));
          }
          curWorkEfforts.add(calEntry);
        }
        if (estimatedStartDate.after(curPeriodEnd))         break;
        if (estimatedCompletionDate.before(curPeriodEnd)) {
          validWorkEfforts.remove(j);
          j--;
        }
      }
      int numEntries=curWorkEfforts.size();
      if (numEntries > maxConcurrentEntries)       maxConcurrentEntries=numEntries;
      entry.put("start",curPeriodStart);
      entry.put("end",curPeriodEnd);
      entry.put("calendarEntries",curWorkEfforts);
      periods.add(entry);
    }
  }
  Map result=new HashMap();
  result.put("periods",periods);
  result.put("maxConcurrentEntries",new Integer(maxConcurrentEntries));
  return result;
}
