{
  LocalDispatcher dispatcher=dctx.getDispatcher();
  GenericDelegator delegator=dctx.getDelegator();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  Locale locale=(Locale)context.get("locale");
  int count=0;
  Map result=null;
  boolean beganTransaction=false;
  try {
    beganTransaction=TransactionUtil.begin();
    List exprs=UtilMisc.toList(new EntityExpr("automaticExtend",EntityOperator.EQUALS,"Y"),new EntityExpr("orderId",EntityOperator.NOT_EQUAL,null),new EntityExpr("productId",EntityOperator.NOT_EQUAL,null));
    EntityCondition cond=new EntityConditionList(exprs,EntityOperator.AND);
    EntityListIterator eli=null;
    eli=delegator.find("Subscription",cond,null,null,null,null);
    if (eli != null) {
      GenericValue subscription;
      while (((subscription=(GenericValue)eli.next()) != null)) {
        Calendar endDate=Calendar.getInstance();
        endDate.setTime(UtilDateTime.nowTimestamp());
        int field=Calendar.MONTH;
        if (subscription.get("canclAutmExtTime") != null && subscription.get("canclAutmExtTimeUomId") != null) {
          if ("TF_day".equals(subscription.getString("canclAutmExtTimeUomId"))) {
            field=Calendar.DAY_OF_YEAR;
          }
 else           if ("TF_wk".equals(subscription.getString("canclAutmExtTimeUomId"))) {
            field=Calendar.WEEK_OF_YEAR;
          }
 else           if ("TF_mon".equals(subscription.getString("canclAutmExtTimeUomId"))) {
            field=Calendar.MONTH;
          }
 else           if ("TF_yr".equals(subscription.getString("canclAutmExtTimeUomId"))) {
            field=Calendar.YEAR;
          }
 else {
            Debug.logWarning("Don't know anything about useTimeUomId [" + subscription.getString("canclAutmExtTimeUomId") + "], defaulting to month",module);
          }
          endDate.add(field,new Integer(subscription.getString("canclAutmExtTime")).intValue());
        }
        Calendar endDateSubscription=Calendar.getInstance();
        endDateSubscription.setTime(subscription.getTimestamp("thruDate"));
        if (endDate.before(endDateSubscription)) {
          continue;
        }
        result=dispatcher.runSync("loadCartFromOrder",UtilMisc.toMap("orderId",subscription.get("orderId"),"userLogin",userLogin));
        ShoppingCart cart=(ShoppingCart)result.get("shoppingCart");
        List cartItems=cart.items();
        Iterator ci=cartItems.iterator();
        while (ci.hasNext()) {
          ShoppingCartItem shoppingCartItem=(ShoppingCartItem)ci.next();
          if (!subscription.get("productId").equals(shoppingCartItem.getProductId())) {
            cart.removeCartItem(shoppingCartItem,dispatcher);
          }
        }
        CheckOutHelper helper=new CheckOutHelper(dispatcher,delegator,cart);
        Map createResp=helper.createOrder(userLogin);
        if (createResp != null && ServiceUtil.isError(createResp)) {
          Debug.logError("Cannot create order for shopping list - " + subscription,module);
        }
 else {
          String orderId=(String)createResp.get("orderId");
          Map payRes=null;
          try {
            payRes=helper.processPayment(ProductStoreWorker.getProductStore(cart.getProductStoreId(),delegator),userLogin);
          }
 catch (          GeneralException e) {
            Debug.logError(e,module);
          }
          if (payRes != null && ServiceUtil.isError(payRes)) {
            Debug.logError("Payment processing problems with shopping list - " + subscription,module);
          }
          subscription.put("automaticExtend","N");
          subscription.store();
          dispatcher.runAsync("sendOrderPayRetryNotification",UtilMisc.toMap("orderId",orderId));
          count++;
        }
      }
      eli.close();
    }
  }
 catch (  GenericServiceException e) {
    Debug.logError("Could call service to create cart",module);
    return ServiceUtil.returnError(e.toString());
  }
catch (  CartItemModifyException e) {
    Debug.logError("Could not modify cart: " + e.toString(),module);
    return ServiceUtil.returnError(e.toString());
  }
catch (  GenericEntityException e) {
    try {
      TransactionUtil.rollback(beganTransaction,"Error creating subscription auto-reorders",e);
    }
 catch (    GenericEntityException e2) {
      Debug.logError(e2,"[GenericDelegator] Could not rollback transaction: " + e2.toString(),module);
    }
    String errMsg="Error while creating new shopping list based automatic reorder" + e.toString();
    Debug.logError(e,errMsg,module);
    return ServiceUtil.returnError(errMsg);
  }
 finally {
    try {
      TransactionUtil.commit(beganTransaction);
    }
 catch (    GenericEntityException e) {
      Debug.logError(e,"Could not commit transaction for creating new shopping list based automatic reorder",module);
    }
  }
  return ServiceUtil.returnSuccess("runSubscriptionAutoReorders finished, " + count + " subscription extended.");
}
