{
  Map result=new HashMap();
  GenericDelegator delegator=ctx.getDelegator();
  LocalDispatcher dispatcher=ctx.getDispatcher();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  Timestamp now=UtilDateTime.nowTimestamp();
  String warehouseFacilityId=(String)context.get("warehouseFacilityId");
  String productionFacilityId=(String)context.get("productionFacilityId");
  Timestamp fromDate=(Timestamp)context.get("fromDate");
  Timestamp thruDate=(Timestamp)context.get("thruDate");
  Map products=FastMap.newInstance();
  try {
    List findOutgoingProductionRunsConds=new LinkedList();
    findOutgoingProductionRunsConds.add(new EntityExpr("workEffortGoodStdTypeId",EntityOperator.EQUALS,"PRUNT_PROD_NEEDED"));
    findOutgoingProductionRunsConds.add(new EntityExpr("statusId",EntityOperator.EQUALS,"WEGS_CREATED"));
    findOutgoingProductionRunsConds.add(new EntityExpr("estimatedStartDate",EntityOperator.GREATER_THAN,fromDate));
    findOutgoingProductionRunsConds.add(new EntityExpr("estimatedStartDate",EntityOperator.LESS_THAN_EQUAL_TO,thruDate));
    List findOutgoingProductionRunsStatusConds=new LinkedList();
    findOutgoingProductionRunsStatusConds.add(new EntityExpr("currentStatusId",EntityOperator.EQUALS,"PRUN_CREATED"));
    findOutgoingProductionRunsStatusConds.add(new EntityExpr("currentStatusId",EntityOperator.EQUALS,"PRUN_SCHEDULED"));
    findOutgoingProductionRunsStatusConds.add(new EntityExpr("currentStatusId",EntityOperator.EQUALS,"PRUN_DOC_PRINTED"));
    findOutgoingProductionRunsConds.add(new EntityConditionList(findOutgoingProductionRunsStatusConds,EntityOperator.OR));
    List resultList=delegator.findByCondition("WorkEffortAndGoods",new EntityConditionList(findOutgoingProductionRunsConds,EntityOperator.AND),null,UtilMisc.toList("-estimatedStartDate"));
    Iterator iteratorResult=resultList.iterator();
    while (iteratorResult.hasNext()) {
      GenericValue genericResult=(GenericValue)iteratorResult.next();
      Double estimatedQuantity=genericResult.getDouble("estimatedQuantity");
      if (estimatedQuantity == null) {
        estimatedQuantity=new Double(0);
      }
      String productId=genericResult.getString("productId");
      if (!products.containsKey(productId)) {
        products.put(productId,new Double(0.0));
      }
      Double totalQuantity=(Double)products.get(productId);
      totalQuantity=new Double(totalQuantity.doubleValue() + estimatedQuantity.doubleValue());
      products.put(productId,totalQuantity);
    }
    Iterator productsIt=products.keySet().iterator();
    while (productsIt.hasNext()) {
      String productId=(String)productsIt.next();
      Double totalQuantity=(Double)products.get(productId);
      double existingQoh=0.0;
      try {
        Map tmpResults=dispatcher.runSync("getInventoryAvailableByFacility",UtilMisc.toMap("productId",productId,"facilityId",productionFacilityId,"userLogin",userLogin));
        if (tmpResults.get("availableToPromiseTotal") != null) {
          existingQoh=((Double)tmpResults.get("quantityOnHandTotal")).doubleValue();
        }
      }
 catch (      GenericServiceException e) {
        Debug.logError(e,"Error counting inventory, assuming qoh = 0 for product [" + productId + "] in facility ["+ productionFacilityId+ "].",module);
      }
      totalQuantity=new Double(totalQuantity.doubleValue() - existingQoh);
      products.put("productId",totalQuantity);
    }
    productsIt=products.keySet().iterator();
    while (productsIt.hasNext()) {
      String productId=(String)productsIt.next();
      double totalQuantity=((Double)products.get(productId)).doubleValue();
      if (totalQuantity > 0) {
        List inventoryItemConds=new LinkedList();
        inventoryItemConds.add(new EntityExpr("availableToPromiseTotal",EntityOperator.GREATER_THAN,new Double(0.0)));
        inventoryItemConds.add(new EntityExpr("facilityId",EntityOperator.EQUALS,warehouseFacilityId));
        inventoryItemConds.add(new EntityExpr("productId",EntityOperator.EQUALS,productId));
        List inventoryItemList=delegator.findByCondition("InventoryItemAndLocation",new EntityConditionList(inventoryItemConds,EntityOperator.AND),null,UtilMisc.toList("-locationTypeEnumId","inventoryItemTypeId","locationSeqId","-availableToPromiseTotal"));
        Iterator inventoryItemIt=inventoryItemList.iterator();
        while (inventoryItemIt.hasNext()) {
          GenericValue inventoryItem=(GenericValue)inventoryItemIt.next();
          double availableToPromiseTotal=((Double)inventoryItem.getDouble("availableToPromiseTotal")).doubleValue();
          double xferQty=0.0;
          if (availableToPromiseTotal >= totalQuantity) {
            xferQty=totalQuantity;
          }
 else {
            xferQty=availableToPromiseTotal;
          }
          try {
            Map tmpInputMap=UtilMisc.toMap("inventoryItemId",inventoryItem.getString("inventoryItemId"),"facilityId",warehouseFacilityId,"facilityIdTo",productionFacilityId,"xferQty",new Double(xferQty));
            tmpInputMap.put("statusId","IXF_REQUESTED");
            tmpInputMap.put("userLogin",userLogin);
            Map tmpResults=dispatcher.runSync("createInventoryTransfer",tmpInputMap);
          }
 catch (          GenericServiceException e) {
            Debug.logError(e,"Error creating inventory trasfer for inventoryItemId [" + inventoryItem.getString("inventoryItemId") + "].",module);
            return ServiceUtil.returnError("Problem running the autoCreateInventoryTransfers service");
          }
          totalQuantity=totalQuantity - xferQty;
          if (totalQuantity == 0) {
            break;
          }
        }
        if (totalQuantity > 0) {
        }
      }
    }
  }
 catch (  GenericEntityException e) {
    Debug.logError(e,"Error",module);
    return ServiceUtil.returnError("Problem running the autoCreateInventoryTransfers service");
  }
  return result;
}
