{
  GenericDelegator delegator=dctx.getDelegator();
  LocalDispatcher dispatcher=dctx.getDispatcher();
  String returnId=(String)context.get("returnId");
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  Locale locale=(Locale)context.get("locale");
  GenericValue returnHeader=null;
  List returnItems=null;
  try {
    returnHeader=delegator.findByPrimaryKey("ReturnHeader",UtilMisc.toMap("returnId",returnId));
    if (returnHeader != null) {
      returnItems=returnHeader.getRelatedByAnd("ReturnItem",UtilMisc.toMap("returnTypeId","RTN_REFUND"));
    }
  }
 catch (  GenericEntityException e) {
    Debug.logError(e,"Problems looking up return information",module);
    return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderErrorGettingReturnHeaderItemInformation",locale));
  }
  BigDecimal adjustments=new BigDecimal(getReturnAdjustmentTotal(delegator,UtilMisc.toMap("returnId",returnId,"returnTypeId","RTN_REFUND")));
  if (returnHeader != null && ((returnItems != null && returnItems.size() > 0) || adjustments.compareTo(ZERO) > 0)) {
    Map itemsByOrder=new HashMap();
    Map totalByOrder=new HashMap();
    Map serviceResult=null;
    try {
      serviceResult=dispatcher.runSync("checkPaymentAmountForRefund",UtilMisc.toMap("returnId",returnId));
    }
 catch (    GenericServiceException e) {
      Debug.logError(e,"Problem running the checkPaymentAmountForRefund service",module);
      return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemsWithCheckPaymentAmountForRefund",locale));
    }
    if (ServiceUtil.isError(serviceResult)) {
      return ServiceUtil.returnError(ServiceUtil.getErrorMessage(serviceResult));
    }
    groupReturnItemsByOrder(returnItems,itemsByOrder,totalByOrder,delegator,returnId,"RTN_REFUND");
    Set itemSet=itemsByOrder.entrySet();
    Iterator itemByOrderIt=itemSet.iterator();
    while (itemByOrderIt.hasNext()) {
      Map.Entry entry=(Map.Entry)itemByOrderIt.next();
      String orderId=(String)entry.getKey();
      List items=(List)entry.getValue();
      Double orderTotal=(Double)totalByOrder.get(orderId);
      GenericValue orderHeader=null;
      List orderPayPrefs=null;
      try {
        orderHeader=delegator.findByPrimaryKey("OrderHeader",UtilMisc.toMap("orderId",orderId));
        orderPayPrefs=orderHeader.getRelated("OrderPaymentPreference",UtilMisc.toMap("statusId","PAYMENT_SETTLED"),UtilMisc.toList("-maxAmount"));
      }
 catch (      GenericEntityException e) {
        Debug.logError(e,"Cannot get Order details for #" + orderId,module);
        continue;
      }
      OrderReadHelper orderReadHelper=new OrderReadHelper(delegator,orderId);
      GenericValue refundPaymentMethod=null;
      GenericValue productStore=orderReadHelper.getProductStore();
      if (UtilValidate.isEmpty(productStore) || UtilValidate.isEmpty(productStore.get("payToPartyId"))) {
        Debug.logError("No payToPartyId found for orderId " + orderId,module);
      }
 else {
        GenericValue orgAcctgPref=null;
        try {
          orgAcctgPref=delegator.findByPrimaryKeyCache("PartyAcctgPreference",UtilMisc.toMap("partyId",productStore.get("payToPartyId")));
        }
 catch (        GenericEntityException e) {
          Debug.logError("Error retrieving PartyAcctgPreference for partyId " + productStore.get("payToPartyId"),module);
        }
        if (UtilValidate.isNotEmpty(orgAcctgPref)) {
          try {
            refundPaymentMethod=orgAcctgPref.getRelatedOne("PaymentMethod");
          }
 catch (          GenericEntityException e) {
            Debug.logError("Error retrieving related refundPaymentMethod from PartyAcctgPreference for partyId " + productStore.get("payToPartyId"),module);
          }
        }
      }
      Timestamp now=UtilDateTime.nowTimestamp();
      Map receivedPaymentTotalsByPaymentMethod=orderReadHelper.getReceivedPaymentTotalsByPaymentMethod();
      Map refundedTotalsByPaymentMethod=orderReadHelper.getReturnedTotalsByPaymentMethod();
      Map prefSplitMap=new HashMap();
      Iterator oppit=orderPayPrefs.iterator();
      while (oppit.hasNext()) {
        GenericValue orderPayPref=(GenericValue)oppit.next();
        String paymentMethodTypeId=orderPayPref.getString("paymentMethodTypeId");
        String orderPayPrefKey=orderPayPref.getString("paymentMethodId") != null ? orderPayPref.getString("paymentMethodId") : orderPayPref.getString("paymentMethodTypeId");
        BigDecimal orderPayPrefReceivedTotal=ZERO;
        if (receivedPaymentTotalsByPaymentMethod.containsKey(orderPayPrefKey)) {
          orderPayPrefReceivedTotal=orderPayPrefReceivedTotal.add(new BigDecimal(((Double)receivedPaymentTotalsByPaymentMethod.get(orderPayPrefKey)).doubleValue()).setScale(decimals,rounding));
        }
        BigDecimal orderPayPrefRefundedTotal=ZERO;
        if (refundedTotalsByPaymentMethod.containsKey(orderPayPrefKey)) {
          orderPayPrefRefundedTotal=orderPayPrefRefundedTotal.add(new BigDecimal(((Double)refundedTotalsByPaymentMethod.get(orderPayPrefKey)).doubleValue()).setScale(decimals,rounding));
        }
        BigDecimal orderPayPrefAvailableTotal=orderPayPrefReceivedTotal.subtract(orderPayPrefRefundedTotal);
        if (orderPayPrefAvailableTotal.compareTo(ZERO) == 1) {
          Map orderPayPrefDetails=new HashMap();
          orderPayPrefDetails.put("orderPaymentPreference",orderPayPref);
          orderPayPrefDetails.put("availableTotal",orderPayPrefAvailableTotal);
          if (prefSplitMap.containsKey(paymentMethodTypeId)) {
            ((List)prefSplitMap.get(paymentMethodTypeId)).add(orderPayPrefDetails);
          }
 else {
            prefSplitMap.put(paymentMethodTypeId,UtilMisc.toList(orderPayPrefDetails));
          }
        }
      }
      BigDecimal amountLeftToRefund=new BigDecimal(orderTotal.doubleValue()).setScale(decimals,rounding);
      List electronicTypes=UtilMisc.toList("CREDIT_CARD","EFT_ACCOUNT","FIN_ACCOUNT","GIFT_CARD");
      List orderedRefundPaymentMethodTypes=new ArrayList();
      orderedRefundPaymentMethodTypes.add("EXT_BILLACT");
      orderedRefundPaymentMethodTypes.add("FIN_ACCOUNT");
      orderedRefundPaymentMethodTypes.add("GIFT_CARD");
      orderedRefundPaymentMethodTypes.add("CREDIT_CARD");
      orderedRefundPaymentMethodTypes.add("EFT_ACCOUNT");
      EntityConditionList pmtConditionList=new EntityConditionList(UtilMisc.toList(new EntityExpr("paymentMethodTypeId",EntityOperator.NOT_IN,orderedRefundPaymentMethodTypes)),EntityOperator.AND);
      List otherPaymentMethodTypes=new ArrayList();
      try {
        otherPaymentMethodTypes=delegator.findByConditionCache("PaymentMethodType",pmtConditionList,null,null);
      }
 catch (      GenericEntityException e) {
        Debug.logError(e,"Cannot get PaymentMethodTypes",module);
        return ServiceUtil.returnError("Problems getting PaymentMethodTypes: " + e.toString());
      }
      orderedRefundPaymentMethodTypes.addAll(EntityUtil.getFieldListFromEntityList(otherPaymentMethodTypes,"paymentMethodTypeId",true));
      Iterator orpmtit=orderedRefundPaymentMethodTypes.iterator();
      while (orpmtit.hasNext() && amountLeftToRefund.compareTo(ZERO) == 1) {
        String paymentMethodTypeId=(String)orpmtit.next();
        if (prefSplitMap.containsKey(paymentMethodTypeId)) {
          List paymentMethodDetails=(List)prefSplitMap.get(paymentMethodTypeId);
          Iterator pmtppit=paymentMethodDetails.iterator();
          while (pmtppit.hasNext() && amountLeftToRefund.compareTo(ZERO) == 1) {
            Map orderPaymentPrefDetails=(Map)pmtppit.next();
            GenericValue orderPaymentPreference=(GenericValue)orderPaymentPrefDetails.get("orderPaymentPreference");
            BigDecimal orderPaymentPreferenceAvailable=(BigDecimal)orderPaymentPrefDetails.get("availableTotal");
            BigDecimal amountToRefund=orderPaymentPreferenceAvailable.min(amountLeftToRefund);
            String paymentId=null;
            if (electronicTypes.contains(paymentMethodTypeId)) {
              try {
                serviceResult=dispatcher.runSync("refundPayment",UtilMisc.toMap("orderPaymentPreference",orderPaymentPreference,"refundAmount",new Double(amountToRefund.setScale(decimals,rounding).doubleValue()),"userLogin",userLogin));
                if (ServiceUtil.isError(serviceResult) || ServiceUtil.isFailure(serviceResult)) {
                  Debug.logError("Error in refund payment: " + ServiceUtil.getErrorMessage(serviceResult),module);
                  continue;
                }
                paymentId=(String)serviceResult.get("paymentId");
              }
 catch (              GenericServiceException e) {
                Debug.logError(e,"Problem running the refundPayment service",module);
                return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemsWithTheRefundSeeLogs",locale));
              }
            }
 else             if (paymentMethodTypeId.equals("EXT_BILLACT")) {
              try {
                serviceResult=dispatcher.runSync("refundBillingAccountPayment",UtilMisc.toMap("orderPaymentPreference",orderPaymentPreference,"refundAmount",new Double(amountToRefund.setScale(decimals,rounding).doubleValue()),"userLogin",userLogin));
                if (ServiceUtil.isError(serviceResult) || ServiceUtil.isFailure(serviceResult)) {
                  Debug.logError("Error in refund payment: " + ServiceUtil.getErrorMessage(serviceResult),module);
                  continue;
                }
                paymentId=(String)serviceResult.get("paymentId");
              }
 catch (              GenericServiceException e) {
                Debug.logError(e,"Problem running the refundPayment service",module);
                return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemsWithTheRefundSeeLogs",locale));
              }
            }
 else {
            }
            Map response=FastMap.newInstance();
            response.put("orderPaymentPreferenceId",orderPaymentPreference.getString("orderPaymentPreferenceId"));
            response.put("responseAmount",new Double(amountToRefund.setScale(decimals,rounding).doubleValue()));
            response.put("responseDate",now);
            response.put("userLogin",userLogin);
            if (paymentId != null) {
              response.put("paymentId",paymentId);
            }
            if (paymentMethodTypeId.equals("EXT_BILLACT")) {
              response.put("billingAccountId",orderReadHelper.getBillingAccount().getString("billingAccountId"));
            }
            Map serviceResults=null;
            try {
              serviceResults=dispatcher.runSync("createReturnItemResponse",response);
              if (ServiceUtil.isError(serviceResults)) {
                return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemsCreatingReturnItemResponseEntity",locale),null,null,serviceResults);
              }
            }
 catch (            GenericServiceException e) {
              Debug.logError(e,"Problems creating new ReturnItemResponse entity",module);
              return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemsCreatingReturnItemResponseEntity",locale));
            }
            String responseId=(String)serviceResults.get("returnItemResponseId");
            Iterator itemsIter=items.iterator();
            while (itemsIter.hasNext()) {
              GenericValue item=(GenericValue)itemsIter.next();
              item.set("returnItemResponseId",responseId);
              item.set("statusId","RETURN_COMPLETED");
              String returnStatusId=delegator.getNextSeqId("ReturnStatus");
              GenericValue returnStatus=delegator.makeValue("ReturnStatus",UtilMisc.toMap("returnStatusId",returnStatusId));
              returnStatus.set("statusId",item.get("statusId"));
              returnStatus.set("returnId",item.get("returnId"));
              returnStatus.set("returnItemSeqId",item.get("returnItemSeqId"));
              returnStatus.set("statusDatetime",now);
              try {
                item.store();
                delegator.create(returnStatus);
              }
 catch (              GenericEntityException e) {
                Debug.logError("Problem updating the ReturnItem entity",module);
                return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemUpdatingReturnItemReturnItemResponseId",locale));
              }
            }
            try {
              serviceResults=dispatcher.runSync("createPaymentApplicationsFromReturnItemResponse",UtilMisc.toMap("returnItemResponseId",responseId,"userLogin",userLogin));
              if (ServiceUtil.isError(serviceResults)) {
                return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemUpdatingReturnItemReturnItemResponseId",locale),null,null,serviceResults);
              }
            }
 catch (            GenericServiceException e) {
              Debug.logError(e,"Problem creating PaymentApplication records for return invoice",module);
              return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,"OrderProblemUpdatingReturnItemReturnItemResponseId",locale));
            }
            amountLeftToRefund=amountLeftToRefund.subtract(amountToRefund);
          }
        }
      }
      if (amountLeftToRefund.compareTo(ZERO) == 1) {
        try {
          Map input=UtilMisc.toMap("userLogin",userLogin,"amount",new Double(amountLeftToRefund.doubleValue()),"statusId","PMNT_NOT_PAID");
          input.put("partyIdTo",returnHeader.get("fromPartyId"));
          input.put("partyIdFrom",returnHeader.get("toPartyId"));
          input.put("paymentTypeId","CUSTOMER_REFUND");
          if (UtilValidate.isNotEmpty(refundPaymentMethod)) {
            input.put("paymentMethodId",refundPaymentMethod.get("paymentMethodId"));
            input.put("paymentMethodTypeId",refundPaymentMethod.get("paymentMethodTypeId"));
          }
 else {
            Debug.logInfo("refundPaymentMethodId not configured in PartyAcctgPreference, not setting for remaining refund amount",module);
          }
          Map results=dispatcher.runSync("createPayment",input);
          if (ServiceUtil.isError(results))           return results;
          input=UtilMisc.toMap("userLogin",userLogin,"paymentId",results.get("paymentId"),"responseAmount",new Double(amountLeftToRefund.doubleValue()));
          results=dispatcher.runSync("createReturnItemResponse",input);
          if (ServiceUtil.isError(results))           return results;
        }
 catch (        GenericServiceException e) {
          return ServiceUtil.returnError(e.getMessage());
        }
      }
    }
  }
  return ServiceUtil.returnSuccess();
}
