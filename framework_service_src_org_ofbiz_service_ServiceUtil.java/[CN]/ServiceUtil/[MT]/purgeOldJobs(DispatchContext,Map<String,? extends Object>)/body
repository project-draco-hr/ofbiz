{
  String sendPool=ServiceConfigUtil.getSendPool();
  int daysToKeep=ServiceConfigUtil.getPurgeJobDays();
  GenericDelegator delegator=dctx.getDelegator();
  Timestamp now=UtilDateTime.nowTimestamp();
  Calendar cal=Calendar.getInstance();
  cal.setTimeInMillis(now.getTime());
  cal.add(Calendar.DAY_OF_YEAR,daysToKeep * -1);
  Timestamp purgeTime=new Timestamp(cal.getTimeInMillis());
  EntityCondition pool=EntityCondition.makeCondition("poolId",sendPool);
  List<EntityExpr> finExp=UtilMisc.toList(EntityCondition.makeCondition("finishDateTime",EntityOperator.NOT_EQUAL,null));
  finExp.add(EntityCondition.makeCondition("finishDateTime",EntityOperator.LESS_THAN,purgeTime));
  List<EntityExpr> canExp=UtilMisc.toList(EntityCondition.makeCondition("cancelDateTime",EntityOperator.NOT_EQUAL,null));
  canExp.add(EntityCondition.makeCondition("cancelDateTime",EntityOperator.LESS_THAN,purgeTime));
  EntityCondition cancelled=EntityCondition.makeCondition(canExp);
  EntityCondition finished=EntityCondition.makeCondition(finExp);
  EntityCondition doneCond=EntityCondition.makeCondition(UtilMisc.toList(cancelled,finished),EntityOperator.OR);
  EntityCondition mainCond=EntityCondition.makeCondition(UtilMisc.toList(doneCond,pool));
  EntityFindOptions findOptions=new EntityFindOptions();
  findOptions.setResultSetType(EntityFindOptions.TYPE_SCROLL_INSENSITIVE);
  findOptions.setMaxRows(1000);
  Transaction parent=null;
  try {
    if (TransactionUtil.getStatus() != TransactionUtil.STATUS_NO_TRANSACTION) {
      parent=TransactionUtil.suspend();
    }
    boolean noMoreResults=false;
    boolean beganTx1=false;
    while (!noMoreResults) {
      List<GenericValue> curList=null;
      try {
        beganTx1=TransactionUtil.begin();
        EntityListIterator foundJobs=delegator.find("JobSandbox",mainCond,null,null,null,findOptions);
        curList=foundJobs.getPartialList(1,1000);
        foundJobs.close();
      }
 catch (      GenericEntityException e) {
        Debug.logError(e,"Cannot obtain job data from datasource",module);
        try {
          TransactionUtil.rollback(beganTx1,e.getMessage(),e);
        }
 catch (        GenericTransactionException e1) {
          Debug.logWarning(e1,module);
        }
        return ServiceUtil.returnError(e.getMessage());
      }
 finally {
        try {
          TransactionUtil.commit(beganTx1);
        }
 catch (        GenericTransactionException e) {
          Debug.logWarning(e,module);
        }
      }
      if (UtilValidate.isNotEmpty(curList)) {
        List<String> runtimeToDelete=FastList.newInstance();
        for (        GenericValue job : curList) {
          String runtimeId=job.getString("runtimeDataId");
          String jobId=job.getString("jobId");
          boolean beganTx2=false;
          try {
            beganTx2=TransactionUtil.begin();
            String logLocation=job.getString("logLocation");
            job.remove();
            if (logLocation != null) {
              File logfile=new File(job.getString("logLocation"));
              logfile.delete();
            }
            runtimeToDelete.add(runtimeId);
          }
 catch (          GenericEntityException e) {
            Debug.logInfo("Cannot remove job data for ID: " + jobId,module);
            try {
              TransactionUtil.rollback(beganTx2,e.getMessage(),e);
            }
 catch (            GenericTransactionException e1) {
              Debug.logWarning(e1,module);
            }
          }
 finally {
            try {
              TransactionUtil.commit(beganTx2);
            }
 catch (            GenericTransactionException e) {
              Debug.logWarning(e,module);
            }
          }
        }
        if (runtimeToDelete.size() > 0) {
          for (          String runtimeId : runtimeToDelete) {
            boolean beganTx3=false;
            try {
              beganTx3=TransactionUtil.begin();
              delegator.removeByAnd("RuntimeData","runtimeDataId",runtimeId);
            }
 catch (            GenericEntityException e) {
              Debug.logInfo("Cannot remove runtime data for ID: " + runtimeId,module);
              try {
                TransactionUtil.rollback(beganTx3,e.getMessage(),e);
              }
 catch (              GenericTransactionException e1) {
                Debug.logWarning(e1,module);
              }
            }
 finally {
              try {
                TransactionUtil.commit(beganTx3);
              }
 catch (              GenericTransactionException e) {
                Debug.logWarning(e,module);
              }
            }
          }
        }
      }
 else {
        noMoreResults=true;
      }
    }
  }
 catch (  GenericTransactionException e) {
    Debug.logError(e,"Unable to suspend transaction; cannot purge jobs!",module);
    return ServiceUtil.returnError(e.getMessage());
  }
 finally {
    if (parent != null) {
      try {
        TransactionUtil.resume(parent);
      }
 catch (      GenericTransactionException e) {
        Debug.logWarning(e,module);
      }
    }
  }
  return ServiceUtil.returnSuccess();
}
