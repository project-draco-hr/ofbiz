{
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  if (userLogin == null) {
    userLogin=SharkContainer.getAdminUser();
  }
  AdminInterface admin=SharkContainer.getAdminInterface();
  ExecutionAdministration exec=admin.getExecutionAdministration();
  boolean beganTrans=false;
  boolean hasError=false;
  Transaction trans=null;
  try {
    beganTrans=TransactionUtil.begin();
    if (!beganTrans) {
      trans=TransactionUtil.suspend();
      beganTrans=TransactionUtil.begin();
    }
    try {
      try {
        exec.connect(userLogin.getString("userLoginId"),userLogin.getString("currentPassword"),null,null);
      }
 catch (      BaseException e) {
        throw new GenericServiceException(e);
      }
catch (      ConnectFailed e) {
        throw new GenericServiceException(e);
      }
      try {
        WfRequester req=new SimpleRequester(userLogin,model,waiter);
        WfProcessMgr mgr=null;
        String location=this.getLocation(model);
        String version=null;
        if (location.indexOf("::") != -1) {
          List splitList=StringUtil.split(location,"::");
          location=(String)splitList.get(0);
          version=(String)splitList.get(1);
        }
        try {
          if (version == null) {
            mgr=exec.getProcessMgr(location,model.invoke);
          }
 else {
            mgr=exec.getProcessMgr(location,version,model.invoke);
          }
        }
 catch (        BaseException e) {
          throw new GenericServiceException(e);
        }
catch (        NotConnected e) {
          throw new GenericServiceException(e);
        }
        if (mgr == null) {
          throw new GenericServiceException("Unable to obtain Process Manager for : " + this.getLocation(model) + " / "+ model.invoke);
        }
        WfProcess proc=null;
        try {
          proc=mgr.create_process(req);
        }
 catch (        BaseException e) {
          throw new GenericServiceException(e);
        }
catch (        NotEnabled e) {
          throw new GenericServiceException(e);
        }
catch (        InvalidRequester e) {
          throw new GenericServiceException(e);
        }
catch (        RequesterRequired e) {
          throw new GenericServiceException(e);
        }
        Map contextSig=null;
        try {
          contextSig=mgr.context_signature();
        }
 catch (        BaseException e) {
          throw new GenericServiceException(e);
        }
        if (contextSig != null) {
          Iterator sigKeys=contextSig.keySet().iterator();
          Map formalParams=new HashMap();
          while (sigKeys.hasNext()) {
            String key=(String)sigKeys.next();
            formalParams.put(key,context.get(key));
          }
          try {
            proc.set_process_context(formalParams);
          }
 catch (          BaseException e) {
            throw new GenericServiceException(e);
          }
catch (          InvalidData e) {
            throw new GenericServiceException(e);
          }
catch (          UpdateNotAllowed e) {
            throw new GenericServiceException(e);
          }
        }
        try {
          proc.start();
        }
 catch (        BaseException e) {
          throw new GenericServiceException(e);
        }
catch (        CannotStart e) {
          throw new GenericServiceException(e);
        }
catch (        AlreadyRunning e) {
          throw new GenericServiceException(e);
        }
      }
 catch (      GenericServiceException e) {
        throw e;
      }
 finally {
        try {
          exec.disconnect();
        }
 catch (        NotConnected e) {
          throw new GenericServiceException(e);
        }
catch (        BaseException e) {
          throw new GenericServiceException(e);
        }
      }
    }
 catch (    GenericServiceException e) {
      hasError=true;
      throw e;
    }
 finally {
      if (hasError) {
        try {
          TransactionUtil.rollback(beganTrans,"Transaction rollback from Shark",null);
        }
 catch (        GenericTransactionException e) {
          Debug.logError(e,"Could not rollback transaction",module);
        }
      }
 else {
        try {
          TransactionUtil.commit(beganTrans);
        }
 catch (        GenericTransactionException e) {
          Debug.logError(e,"Could not commit transaction",module);
          throw new GenericServiceException("Commit transaction failed");
        }
      }
    }
  }
 catch (  GenericTransactionException e) {
    throw new GenericServiceException(e);
  }
 finally {
    if (trans != null) {
      try {
        TransactionUtil.resume(trans);
      }
 catch (      GenericTransactionException e) {
        throw new GenericServiceException(e);
      }
    }
  }
  return waiter;
}
