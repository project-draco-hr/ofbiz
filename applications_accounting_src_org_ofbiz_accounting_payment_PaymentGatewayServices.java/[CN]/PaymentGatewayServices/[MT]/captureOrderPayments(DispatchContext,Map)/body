{
  GenericDelegator delegator=dctx.getDelegator();
  LocalDispatcher dispatcher=dctx.getDispatcher();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  String orderId=(String)context.get("orderId");
  String invoiceId=(String)context.get("invoiceId");
  String billingAccountId=(String)context.get("billingAccountId");
  Double captureAmount=(Double)context.get("captureAmount");
  Map result=new HashMap();
  GenericValue orderHeader=null;
  List paymentPrefs=null;
  try {
    orderHeader=delegator.findByPrimaryKey("OrderHeader",UtilMisc.toMap("orderId",orderId));
    Map lookupMap=UtilMisc.toMap("orderId",orderId,"statusId","PAYMENT_AUTHORIZED");
    List orderList=UtilMisc.toList("-maxAmount");
    paymentPrefs=delegator.findByAnd("OrderPaymentPreference",lookupMap,orderList);
  }
 catch (  GenericEntityException gee) {
    Debug.logError(gee,"Problems getting entity record(s), see stack trace",module);
    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_ERROR);
    result.put(ModelService.ERROR_MESSAGE,"ERROR: Could not get order information (" + gee.toString() + ").");
    return result;
  }
  if (orderHeader == null) {
    return ServiceUtil.returnError("Could not find OrderHeader with orderId: " + orderId + "; not processing payments.");
  }
  GenericValue billingAccount=null;
  BigDecimal billingAccountBalance=null;
  BigDecimal billingAccountAvail=null;
  BigDecimal billingAccountCaptureAmount=ZERO;
  Map billingAccountInfo=null;
  if (UtilValidate.isNotEmpty(billingAccountId)) {
    try {
      billingAccountInfo=dispatcher.runSync("calcBillingAccountBalance",UtilMisc.toMap("billingAccountId",billingAccountId));
    }
 catch (    GenericServiceException e) {
      Debug.logError(e,"Unable to get billing account information for #" + billingAccountId,module);
    }
  }
  if (billingAccountInfo != null) {
    billingAccount=(GenericValue)billingAccountInfo.get("billingAccount");
    Double billingAccountBalanceD=(Double)billingAccountInfo.get("netAccountBalance");
    billingAccountBalance=new BigDecimal(billingAccountBalanceD.doubleValue());
  }
  if (billingAccount != null && billingAccountBalance != null) {
    try {
      billingAccountAvail=BillingAccountWorker.getBillingAccountAvailableBalance(billingAccount);
      BigDecimal captureAmountBd=new BigDecimal(captureAmount.doubleValue());
      billingAccountCaptureAmount=billingAccountAvail.min(captureAmountBd);
      Debug.logInfo("billing account avail = [" + billingAccountAvail + "] capture amount = ["+ billingAccountCaptureAmount+ "]",module);
      Map tmpResult=dispatcher.runSync("captureBillingAccountPayment",UtilMisc.toMap("invoiceId",invoiceId,"billingAccountId",billingAccountId,"captureAmount",new Double(billingAccountCaptureAmount.doubleValue()),"userLogin",userLogin));
      if (ServiceUtil.isError(tmpResult)) {
        return tmpResult;
      }
      if (billingAccountCaptureAmount.compareTo(captureAmountBd) == -1) {
        BigDecimal outstandingAmount=captureAmountBd.subtract(billingAccountCaptureAmount).setScale(decimals,rounding);
        captureAmount=new Double(outstandingAmount.doubleValue());
      }
 else {
        Debug.logInfo("Amount to capture [" + captureAmount + "] was fully captured in Payment ["+ tmpResult.get("paymentId")+ "].",module);
        result=ServiceUtil.returnSuccess();
        result.put("processResult","COMPLETE");
        return result;
      }
    }
 catch (    GenericEntityException ex) {
      return ServiceUtil.returnError(ex.getMessage());
    }
catch (    GenericServiceException ex) {
      return ServiceUtil.returnError(ex.getMessage());
    }
  }
  if (paymentPrefs == null || paymentPrefs.size() == 0) {
    Debug.logWarning("No orderPaymentPreferences available to capture",module);
    result.put("processResult","COMPLETE");
    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);
    return result;
  }
  OrderReadHelper orh=new OrderReadHelper(orderHeader);
  BigDecimal orderGrandTotal=orh.getOrderGrandTotalBd();
  orderGrandTotal=orderGrandTotal.setScale(2,BigDecimal.ROUND_HALF_UP);
  double orderTotal=orderGrandTotal.doubleValue();
  double totalPayments=PaymentWorker.getPaymentsTotal(orh.getOrderPayments());
  double remainingTotal=orderTotal - totalPayments;
  if (Debug.infoOn())   Debug.logInfo("Capture Remaining Total: " + remainingTotal,module);
  String currencyFormat=UtilProperties.getPropertyValue("general.properties","currency.decimal.format","##0.00");
  DecimalFormat formatter=new DecimalFormat(currencyFormat);
  String remainingTotalString=formatter.format(remainingTotal);
  try {
    Number remaining=formatter.parse(remainingTotalString);
    if (remaining != null) {
      remainingTotal=remaining.doubleValue();
    }
  }
 catch (  ParseException e) {
    Debug.logError(e,"Problem getting parsed remaining total",module);
    return ServiceUtil.returnError("ERROR: Cannot parse grand total from formatted string; see logs");
  }
  if (captureAmount == null) {
    captureAmount=new Double(remainingTotal);
  }
  double amountToCapture=captureAmount.doubleValue();
  if (Debug.infoOn())   Debug.logInfo("Actual Expected Capture Amount : " + amountToCapture,module);
  List finished=new ArrayList();
  Iterator payments=paymentPrefs.iterator();
  while (payments.hasNext()) {
    GenericValue paymentPref=(GenericValue)payments.next();
    GenericValue authTrans=getAuthTransaction(paymentPref);
    if (authTrans == null) {
      continue;
    }
    Double authAmount=authTrans.getDouble("amount");
    if (authAmount == null)     authAmount=new Double(0.00);
    if (authAmount.doubleValue() == 0.00) {
      Debug.logInfo("Nothing to capture; authAmount = 0",module);
      continue;
    }
    if (authAmount.doubleValue() > remainingTotal) {
      authAmount=new Double(remainingTotal);
    }
    double amountToBillAccount=0.00;
    if (billingAccountAvail != null) {
      amountToBillAccount=authAmount.doubleValue() + billingAccountAvail.doubleValue();
    }
    double amountThisCapture=0.00;
    if (authAmount.doubleValue() >= amountToCapture) {
      amountThisCapture=amountToCapture;
    }
 else     if (payments.hasNext()) {
      amountThisCapture=authAmount.doubleValue();
    }
 else     if (billingAccountAvail != null && amountToBillAccount >= amountToCapture) {
      amountThisCapture=authAmount.doubleValue();
    }
 else {
      Debug.logError("The amount to capture was more then what was authorized; we only captured the authorized amount : " + paymentPref,module);
      amountThisCapture=authAmount.doubleValue();
    }
    Map captureResult=capturePayment(dctx,userLogin,orh,paymentPref,amountThisCapture);
    if (captureResult != null) {
      Double amountCaptured=(Double)captureResult.get("captureAmount");
      if (amountCaptured != null)       amountToCapture-=amountCaptured.doubleValue();
      finished.add(captureResult);
      captureResult.put("invoiceId",invoiceId);
      try {
        processResult(dctx,captureResult,userLogin,paymentPref);
      }
 catch (      GeneralException e) {
        Debug.logError(e,"Trouble processing the result; captureResult: " + captureResult,module);
        return ServiceUtil.returnError("Trouble processing the capture results");
      }
      BigDecimal totalAmountCaptured=new BigDecimal(amountThisCapture);
      totalAmountCaptured=totalAmountCaptured.add(billingAccountCaptureAmount).setScale(decimals,rounding);
      if (authAmount.doubleValue() > totalAmountCaptured.doubleValue()) {
        double newAmount=authAmount.doubleValue() - totalAmountCaptured.doubleValue();
        Debug.logInfo("Creating payment preference split",module);
        String newPrefId=delegator.getNextSeqId("OrderPaymentPreference");
        GenericValue newPref=delegator.makeValue("OrderPaymentPreference",UtilMisc.toMap("orderPaymentPreferenceId",newPrefId));
        newPref.set("orderId",paymentPref.get("orderId"));
        newPref.set("paymentMethodTypeId",paymentPref.get("paymentMethodTypeId"));
        newPref.set("paymentMethodId",paymentPref.get("paymentMethodId"));
        newPref.set("maxAmount",paymentPref.get("maxAmount"));
        newPref.set("statusId","PAYMENT_NOT_AUTH");
        newPref.set("createdDate",UtilDateTime.nowTimestamp());
        if (userLogin != null) {
          newPref.set("createdByUserLogin",userLogin.getString("userLoginId"));
        }
        Debug.logInfo("New preference : " + newPref,module);
        Map processorResult=null;
        try {
          delegator.create(newPref);
          processorResult=authPayment(dispatcher,userLogin,orh,newPref,newAmount,false);
          if (processorResult != null) {
            boolean authResult=processResult(dctx,processorResult,userLogin,newPref);
            if (!authResult) {
              Debug.logError("Authorization failed : " + newPref + " : "+ processorResult,module);
            }
          }
 else {
            Debug.logError("Payment not authorized : " + newPref + " : "+ processorResult,module);
          }
        }
 catch (        GenericEntityException e) {
          Debug.logError(e,"ERROR: cannot create new payment preference : " + newPref,module);
        }
catch (        GeneralException e) {
          if (processorResult != null) {
            Debug.logError(e,"Trouble processing the auth result: " + newPref + " : "+ processorResult,module);
          }
 else {
            Debug.logError(e,"Trouble authorizing the payment: " + newPref,module);
          }
        }
      }
    }
 else {
      Debug.logError("Payment not captured",module);
      continue;
    }
  }
  if (amountToCapture > 0.00) {
    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);
    result.put("processResult","FAILED");
    return result;
  }
 else {
    result.put(ModelService.RESPONSE_MESSAGE,ModelService.RESPOND_SUCCESS);
    result.put("processResult","COMPLETE");
    return result;
  }
}
