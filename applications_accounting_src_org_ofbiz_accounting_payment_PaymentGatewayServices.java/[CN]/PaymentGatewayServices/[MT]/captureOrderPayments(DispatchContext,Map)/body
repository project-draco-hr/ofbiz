{
  GenericDelegator delegator=dctx.getDelegator();
  LocalDispatcher dispatcher=dctx.getDispatcher();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  String orderId=(String)context.get("orderId");
  String invoiceId=(String)context.get("invoiceId");
  String billingAccountId=(String)context.get("billingAccountId");
  Double captureAmount=(Double)context.get("captureAmount");
  BigDecimal captureAmountBd=new BigDecimal(captureAmount.doubleValue());
  GenericValue orderHeader=null;
  List paymentPrefs=null;
  try {
    orderHeader=delegator.findByPrimaryKey("OrderHeader",UtilMisc.toMap("orderId",orderId));
    Map lookupMap=UtilMisc.toMap("orderId",orderId,"statusId","PAYMENT_AUTHORIZED");
    List orderList=UtilMisc.toList("-maxAmount");
    paymentPrefs=delegator.findByAnd("OrderPaymentPreference",lookupMap,orderList);
  }
 catch (  GenericEntityException gee) {
    Debug.logError(gee,"Problems getting entity record(s), see stack trace",module);
    return ServiceUtil.returnError("ERROR: Could not get order information (" + gee.toString() + ").");
  }
  if (orderHeader == null) {
    return ServiceUtil.returnError("Could not find OrderHeader with orderId: " + orderId + "; not processing payments.");
  }
  OrderReadHelper orh=new OrderReadHelper(orderHeader);
  BigDecimal orderGrandTotal=orh.getOrderGrandTotalBd();
  orderGrandTotal=orderGrandTotal.setScale(2,BigDecimal.ROUND_HALF_UP);
  BigDecimal totalPayments=PaymentWorker.getPaymentsTotal(orh.getOrderPayments());
  totalPayments=totalPayments.setScale(2,BigDecimal.ROUND_HALF_UP);
  BigDecimal remainingTotalBd=orderGrandTotal.subtract(totalPayments);
  if (Debug.infoOn())   Debug.logInfo("Capture Remaining Total: " + remainingTotalBd,module);
  GenericValue billingAccount=null;
  BigDecimal billingAccountAvail=null;
  BigDecimal billingAccountCaptureAmount=ZERO;
  Map billingAccountInfo=null;
  if (UtilValidate.isNotEmpty(billingAccountId)) {
    try {
      billingAccountInfo=dispatcher.runSync("calcBillingAccountBalance",UtilMisc.toMap("billingAccountId",billingAccountId));
    }
 catch (    GenericServiceException e) {
      Debug.logError(e,"Unable to get billing account information for #" + billingAccountId,module);
    }
  }
  if (billingAccountInfo != null) {
    billingAccount=(GenericValue)billingAccountInfo.get("billingAccount");
    Double availableToCapture=(Double)billingAccountInfo.get("availableToCapture");
    billingAccountAvail=new BigDecimal(availableToCapture.doubleValue());
  }
  if (billingAccount != null && billingAccountAvail != null) {
    try {
      BigDecimal billingAccountMaxAmount=new BigDecimal(orh.getBillingAccountMaxAmount());
      billingAccountCaptureAmount=billingAccountMaxAmount.min(billingAccountAvail).min(captureAmountBd);
      Debug.logInfo("billing account avail = [" + billingAccountAvail + "] capture amount = ["+ billingAccountCaptureAmount+ "] maxAmount = ["+ billingAccountMaxAmount+ "]",module);
      if (billingAccountCaptureAmount.compareTo(ZERO) == 1) {
        Map tmpResult=dispatcher.runSync("captureBillingAccountPayment",UtilMisc.toMap("invoiceId",invoiceId,"billingAccountId",billingAccountId,"captureAmount",new Double(billingAccountCaptureAmount.doubleValue()),"orderId",orderId,"userLogin",userLogin));
        if (ServiceUtil.isError(tmpResult)) {
          return tmpResult;
        }
        if (billingAccountCaptureAmount.compareTo(captureAmountBd) == -1) {
          BigDecimal outstandingAmount=captureAmountBd.subtract(billingAccountCaptureAmount).setScale(decimals,rounding);
          captureAmountBd=outstandingAmount;
        }
 else {
          Debug.logInfo("Amount to capture [" + captureAmountBd + "] was fully captured in Payment ["+ tmpResult.get("paymentId")+ "].",module);
          Map result=ServiceUtil.returnSuccess();
          result.put("processResult","COMPLETE");
          return result;
        }
      }
    }
 catch (    GenericServiceException ex) {
      return ServiceUtil.returnError(ex.getMessage());
    }
  }
  if (paymentPrefs == null || paymentPrefs.size() == 0) {
    Debug.logWarning("No orderPaymentPreferences available to capture",module);
    Map result=ServiceUtil.returnSuccess();
    result.put("processResult","COMPLETE");
    return result;
  }
  BigDecimal amountToCapture=ZERO;
  if (captureAmountBd == null) {
    amountToCapture=remainingTotalBd;
  }
 else {
    amountToCapture=captureAmountBd;
  }
  if (Debug.infoOn())   Debug.logInfo("Actual Expected Capture Amount : " + amountToCapture,module);
  Iterator payments=paymentPrefs.iterator();
  while (payments.hasNext()) {
    GenericValue paymentPref=(GenericValue)payments.next();
    GenericValue authTrans=getAuthTransaction(paymentPref);
    if (authTrans == null) {
      continue;
    }
    GenericValue captureTrans=getCaptureTransaction(paymentPref);
    if (captureTrans != null) {
      Debug.logWarning("Attempt to capture and already captured preference: " + captureTrans,module);
      continue;
    }
    BigDecimal authAmount=authTrans.getBigDecimal("amount");
    if (authAmount == null)     authAmount=new BigDecimal(0.00);
    authAmount=authAmount.setScale(2,BigDecimal.ROUND_HALF_UP);
    if (authAmount.compareTo(ZERO) == 0) {
      Debug.logInfo("Nothing to capture; authAmount = 0",module);
      continue;
    }
    if (authAmount.compareTo(remainingTotalBd) == 1) {
      authAmount=new BigDecimal(remainingTotalBd.doubleValue());
    }
    BigDecimal amountToBillAccount=ZERO;
    if (billingAccountAvail != null) {
      amountToBillAccount=authAmount.add(billingAccountAvail).setScale(2,BigDecimal.ROUND_HALF_UP);
    }
    BigDecimal amountThisCapture;
    if (authAmount.compareTo(amountToCapture) >= 0) {
      amountThisCapture=amountToCapture;
    }
 else     if (payments.hasNext()) {
      amountThisCapture=authAmount;
    }
 else     if (billingAccountAvail != null && amountToBillAccount.compareTo(amountToCapture) >= 0) {
      amountThisCapture=authAmount;
    }
 else {
      Debug.logError("The amount to capture was more then what was authorized; we only captured the authorized amount : " + paymentPref,module);
      amountThisCapture=authAmount;
    }
    Debug.logInfo("Payment preference = [" + paymentPref + "] amount to capture = ["+ amountToCapture+ "] amount of this capture = ["+ amountThisCapture+ "] actual auth amount =["+ authAmount+ "] amountToBillAccount = ["+ amountToBillAccount+ "]",module);
    Map captureResult=capturePayment(dctx,userLogin,orh,paymentPref,amountThisCapture.doubleValue());
    if (captureResult != null) {
      Double amountCaptured=(Double)captureResult.get("captureAmount");
      if (amountCaptured == null) {
        amountCaptured=(Double)captureResult.get("processAmount");
      }
      BigDecimal amountCapturedBd=new BigDecimal(amountCaptured.doubleValue());
      amountCapturedBd=amountCapturedBd.setScale(2,BigDecimal.ROUND_HALF_UP);
      if (amountCaptured != null) {
        amountToCapture=amountToCapture.subtract(amountCapturedBd);
      }
      captureResult.put("invoiceId",invoiceId);
      try {
        processResult(dctx,captureResult,userLogin,paymentPref);
      }
 catch (      GeneralException e) {
        Debug.logError(e,"Trouble processing the result; captureResult: " + captureResult,module);
        return ServiceUtil.returnError("Trouble processing the capture results");
      }
      if (authAmount.compareTo(amountThisCapture) == 1) {
        BigDecimal splitAmount=authAmount.subtract(amountThisCapture);
        Map splitResp=null;
        try {
          Map splitCtx=UtilMisc.toMap("userLogin",userLogin,"orderPaymentPreference",paymentPref,"splitAmount",splitAmount);
          dispatcher.addCommitService("processCaptureSplitPayment",splitCtx,true);
        }
 catch (        GenericServiceException e) {
          Debug.logWarning(e,"Problem processing the capture split payment",module);
        }
        if (ServiceUtil.isError(splitResp)) {
          Debug.logWarning("Problem processing the capture split payment: " + ServiceUtil.getErrorMessage(splitResp),module);
        }
      }
    }
 else {
      Debug.logError("Payment not captured",module);
    }
  }
  if (amountToCapture.compareTo(ZERO) == 1) {
    GenericValue productStore=orh.getProductStore();
    if (!UtilValidate.isEmpty(productStore)) {
      boolean shipIfCaptureFails=UtilValidate.isEmpty(productStore.get("shipIfCaptureFails")) || "Y".equalsIgnoreCase(productStore.getString("shipIfCaptureFails"));
      if (!shipIfCaptureFails) {
        return ServiceUtil.returnError("Cannot ship order because credit card captures were unsuccessful");
      }
    }
    Map result=ServiceUtil.returnSuccess();
    result.put("processResult","FAILED");
    return result;
  }
 else {
    Map result=ServiceUtil.returnSuccess();
    result.put("processResult","COMPLETE");
    return result;
  }
}
