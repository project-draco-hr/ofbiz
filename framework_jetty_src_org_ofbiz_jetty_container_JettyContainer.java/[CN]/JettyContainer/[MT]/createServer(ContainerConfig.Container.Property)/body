{
  Server server=new Server();
  for (  ContainerConfig.Container.Property props : serverConfig.properties.values()) {
    if ("send-server-version".equals(props.name)) {
      if ("false".equalsIgnoreCase(props.value)) {
        server.setSendServerVersion(false);
      }
    }
 else     if ("connector".equals(props.value)) {
      if ("http".equals(props.getProperty("type").value)) {
        AbstractConnector connector=new SocketConnector();
        setConnectorOptions(connector,props);
        server.addConnector(connector);
      }
 else       if ("https".equals(props.getProperty("type").value)) {
        SslSocketConnector connector=new SslSocketConnector();
        setConnectorOptions(connector,props);
        if (props.getProperty("keystore") != null) {
          connector.setKeystore(props.getProperty("keystore").value);
        }
        if (props.getProperty("password") != null) {
          connector.setPassword(props.getProperty("password").value);
        }
        if (props.getProperty("key-password") != null) {
          connector.setKeyPassword(props.getProperty("key-password").value);
        }
        if (props.getProperty("client-auth") != null) {
          if ("need".equals(props.getProperty("client-auth").value)) {
            connector.setNeedClientAuth(true);
          }
 else           if ("want".equals(props.getProperty("client-auth").value)) {
            connector.setWantClientAuth(true);
          }
        }
        server.addConnector(connector);
      }
 else       if ("nio-http".equals(props.getProperty("type").value)) {
        AbstractConnector connector=new SelectChannelConnector();
        setConnectorOptions(connector,props);
        server.addConnector(connector);
      }
 else       if ("nio-https".equals(props.getProperty("type").value)) {
        SslSelectChannelConnector connector=new SslSelectChannelConnector();
        setConnectorOptions(connector,props);
        if (props.getProperty("keystore") != null) {
          connector.setKeystore(props.getProperty("keystore").value);
        }
        if (props.getProperty("password") != null) {
          connector.setPassword(props.getProperty("password").value);
        }
        if (props.getProperty("key-password") != null) {
          connector.setKeyPassword(props.getProperty("key-password").value);
        }
        if (props.getProperty("need-client-auth") != null) {
          boolean needClientAuth="true".equalsIgnoreCase(props.getProperty("need-client-auth").value);
          connector.setNeedClientAuth(needClientAuth);
        }
        server.addConnector(connector);
      }
 else       if ("ajp13".equals(props.getProperty("type").value)) {
        AbstractConnector connector=new Ajp13SocketConnector();
        setConnectorOptions(connector,props);
        server.addConnector(connector);
      }
    }
 else     if ("request-log".equals(props.value)) {
      RequestLogHandler requestLogHandler=new RequestLogHandler();
      NCSARequestLog requestLog=new NCSARequestLog();
      if (props.getProperty("filename") != null) {
        requestLog.setFilename(props.getProperty("filename").value);
      }
      if (props.getProperty("append") != null) {
        requestLog.setAppend("true".equalsIgnoreCase(props.getProperty("append").value));
      }
      if (props.getProperty("extended") != null) {
        requestLog.setExtended("true".equalsIgnoreCase(props.getProperty("extended").value));
      }
      if (props.getProperty("timezone") != null) {
        requestLog.setLogTimeZone(props.getProperty("timezone").value);
      }
      if (props.getProperty("date-format") != null) {
        requestLog.setLogDateFormat(props.getProperty("date-format").value);
      }
      if (props.getProperty("retain-days") != null) {
        int days=90;
        try {
          days=Integer.parseInt(props.getProperty("retain-days").value);
        }
 catch (        NumberFormatException e) {
          days=90;
        }
        requestLog.setRetainDays(days);
      }
      requestLogHandler.setRequestLog(requestLog);
      server.addHandler(requestLogHandler);
    }
  }
  return server;
}
