{
  GenericDelegator delegator=dctx.getDelegator();
  LocalDispatcher dispatcher=dctx.getDispatcher();
  GenericValue userLogin=(GenericValue)context.get("userLogin");
  Map ordersToUpdate=new HashMap();
  Map ordersToCancel=new HashMap();
  List inventoryItems=null;
  try {
    List exprs=UtilMisc.toList(new EntityExpr("availableToPromiseTotal",EntityOperator.LESS_THAN,new Double(0)));
    inventoryItems=delegator.findByAnd("InventoryItem",exprs);
  }
 catch (  GenericEntityException e) {
    Debug.logError(e,"Trouble getting inventory items",module);
    return ServiceUtil.returnError("Problem getting InventoryItem records");
  }
  if (inventoryItems == null) {
    Debug.logInfo("No items out of stock; no backorders to worry about",module);
    return ServiceUtil.returnSuccess();
  }
  Debug.log("OOS Inventory Items: " + inventoryItems.size(),module);
  Iterator itemsIter=inventoryItems.iterator();
  while (itemsIter.hasNext()) {
    GenericValue inventoryItem=(GenericValue)itemsIter.next();
    List shipmentAndItems=null;
    try {
      List exprs=new ArrayList();
      exprs.add(new EntityExpr("productId",EntityOperator.EQUALS,inventoryItem.get("productId")));
      exprs.add(new EntityExpr("destinationFacilityId",EntityOperator.EQUALS,inventoryItem.get("facilityId")));
      exprs.add(new EntityExpr("statusId",EntityOperator.NOT_EQUAL,"SHIPMENT_DELIVERED"));
      exprs.add(new EntityExpr("statusId",EntityOperator.NOT_EQUAL,"SHIPMENT_CANCELLED"));
      shipmentAndItems=delegator.findByAnd("ShipmentAndItem",exprs,UtilMisc.toList("estimatedArrivalDate"));
    }
 catch (    GenericEntityException e) {
      Debug.logError(e,"Problem getting ShipmentAndItem records",module);
      return ServiceUtil.returnError("Problem getting ShipmentAndItem records");
    }
    List reservations=null;
    try {
      reservations=inventoryItem.getRelated("OrderItemShipGrpInvRes",null,UtilMisc.toList("-reservedDatetime"));
    }
 catch (    GenericEntityException e) {
      Debug.logError(e,"Problem getting related reservations",module);
      return ServiceUtil.returnError("Problem getting related reservations");
    }
    if (reservations == null) {
      Debug.logWarning("No outstanding reservations for this inventory item, why is it negative then?",module);
      continue;
    }
    Debug.log("Reservations for item: " + reservations.size(),module);
    double availableBeforeReserved=inventoryItem.getDouble("availableToPromiseTotal").doubleValue();
    Iterator ri=reservations.iterator();
    while (ri.hasNext()) {
      GenericValue reservation=(GenericValue)ri.next();
      String orderId=reservation.getString("orderId");
      String orderItemSeqId=reservation.getString("orderItemSeqId");
      Timestamp promisedDate=reservation.getTimestamp("promisedDatetime");
      Timestamp currentPromiseDate=reservation.getTimestamp("currentPromisedDate");
      Timestamp actualPromiseDate=currentPromiseDate;
      if (actualPromiseDate == null) {
        if (promisedDate != null) {
          actualPromiseDate=promisedDate;
        }
 else {
          actualPromiseDate=reservation.getTimestamp("reservedDatetime");
        }
      }
      Debug.log("Promised Date: " + actualPromiseDate,module);
      Timestamp nextShipDate=null;
      double availableAtTime=0.00;
      Iterator si=shipmentAndItems.iterator();
      while (si.hasNext()) {
        GenericValue shipmentItem=(GenericValue)si.next();
        availableAtTime+=shipmentItem.getDouble("quantity").doubleValue();
        if (availableAtTime >= availableBeforeReserved) {
          nextShipDate=shipmentItem.getTimestamp("estimatedArrivalDate");
          break;
        }
      }
      Debug.log("Next Ship Date: " + nextShipDate,module);
      Calendar pCal=Calendar.getInstance();
      pCal.setTimeInMillis(actualPromiseDate.getTime());
      pCal.add(Calendar.DAY_OF_YEAR,-1);
      Timestamp modifiedPromisedDate=new Timestamp(pCal.getTimeInMillis());
      Timestamp now=UtilDateTime.nowTimestamp();
      Debug.log("Promised Date + 1: " + modifiedPromisedDate,module);
      Debug.log("Now: " + now,module);
      if (nextShipDate == null || nextShipDate.after(actualPromiseDate)) {
        if (nextShipDate == null && modifiedPromisedDate.after(now)) {
          Debug.log("No ship date known yet, but promised date hasn't approached, assuming it will be here on time",module);
        }
 else {
          Debug.log("We won't ship on time, getting notification info",module);
          Map notifyItems=(Map)ordersToUpdate.get(orderId);
          if (notifyItems == null) {
            notifyItems=new HashMap();
          }
          notifyItems.put(orderItemSeqId,nextShipDate);
          ordersToUpdate.put(orderId,notifyItems);
          Calendar sCal=Calendar.getInstance();
          sCal.setTimeInMillis(actualPromiseDate.getTime());
          sCal.add(Calendar.DAY_OF_YEAR,30);
          Timestamp farPastPromised=new Timestamp(sCal.getTimeInMillis());
          boolean needToCancel=false;
          if (nextShipDate == null || nextShipDate.after(farPastPromised)) {
            Debug.log("Ship date is >30 past the promised date",module);
            needToCancel=true;
          }
 else           if (currentPromiseDate != null && actualPromiseDate.equals(currentPromiseDate)) {
            needToCancel=true;
          }
          if (needToCancel) {
            Debug.log("Flagging the item to auto-cancel",module);
            Map cancelItems=(Map)ordersToCancel.get(orderId);
            if (cancelItems == null) {
              cancelItems=new HashMap();
            }
            cancelItems.put(orderItemSeqId,farPastPromised);
            ordersToCancel.put(orderId,cancelItems);
          }
          try {
            reservation.set("currentPromisedDate",nextShipDate);
            reservation.store();
          }
 catch (          GenericEntityException e) {
            Debug.logError(e,"Problem storing reservation : " + reservation,module);
          }
        }
      }
      availableBeforeReserved-=reservation.getDouble("quantity").doubleValue();
    }
  }
  List ordersToNotify=new ArrayList();
  Set orderSet=ordersToUpdate.keySet();
  Iterator orderIter=orderSet.iterator();
  while (orderIter.hasNext()) {
    String orderId=(String)orderIter.next();
    Map backOrderedItems=(Map)ordersToUpdate.get(orderId);
    Map cancelItems=(Map)ordersToCancel.get(orderId);
    boolean cancelAll=false;
    Timestamp cancelAllTime=null;
    List orderItemShipGroups=null;
    try {
      orderItemShipGroups=delegator.findByAnd("OrderItemShipGroup",UtilMisc.toMap("orderId",orderId));
    }
 catch (    GenericEntityException e) {
      Debug.logError(e,"Cannot get OrderItemShipGroups from orderId" + orderId,module);
    }
    Iterator orderItemShipGroupsIter=orderItemShipGroups.iterator();
    while (orderItemShipGroupsIter.hasNext()) {
      GenericValue orderItemShipGroup=(GenericValue)orderItemShipGroupsIter.next();
      List orderItems=new java.util.Vector();
      List orderItemShipGroupAssoc=null;
      try {
        orderItemShipGroupAssoc=delegator.findByAnd("OrderItemShipGroupAssoc",UtilMisc.toMap("shipGroupSeqId",orderItemShipGroup.get("shipGroupSeqId"),"orderId",orderId));
        Iterator assocIter=orderItemShipGroupAssoc.iterator();
        while (assocIter.hasNext()) {
          GenericValue assoc=(GenericValue)assocIter.next();
          GenericValue orderItem=assoc.getRelatedOne("OrderItem");
          if (orderItem != null) {
            orderItems.add(orderItem);
          }
        }
      }
 catch (      GenericEntityException e) {
        Debug.logError(e,"Problem fetching OrderItemShipGroupAssoc",module);
      }
      boolean maySplit=false;
      if (orderItemShipGroup != null && orderItemShipGroup.get("maySplit") != null) {
        maySplit=orderItemShipGroup.getBoolean("maySplit").booleanValue();
      }
      if (!maySplit && cancelItems != null) {
        cancelAll=true;
        Set cancelSet=cancelItems.keySet();
        cancelAllTime=(Timestamp)cancelItems.get(cancelSet.iterator().next());
      }
      if (cancelItems == null) {
        cancelItems=new HashMap();
      }
      if (orderItems != null) {
        List toBeStored=new ArrayList();
        Iterator orderItemsIter=orderItems.iterator();
        while (orderItemsIter.hasNext()) {
          GenericValue orderItem=(GenericValue)orderItemsIter.next();
          String orderItemSeqId=orderItem.getString("orderItemSeqId");
          Timestamp shipDate=(Timestamp)backOrderedItems.get(orderItemSeqId);
          Timestamp cancelDate=(Timestamp)cancelItems.get(orderItemSeqId);
          Timestamp currentCancelDate=orderItem.getTimestamp("autoCancelDate");
          Debug.logError("OI: " + orderId + " SEQID: "+ orderItemSeqId+ " cancelAll: "+ cancelAll+ " cancelDate: "+ cancelDate,module);
          if (backOrderedItems.containsKey(orderItemSeqId)) {
            orderItem.set("estimatedShipDate",shipDate);
            if (currentCancelDate == null) {
              if (cancelAll || cancelDate != null) {
                if (orderItem.get("dontCancelSetUserLogin") == null && orderItem.get("dontCancelSetDate") == null) {
                  if (cancelAllTime != null) {
                    orderItem.set("autoCancelDate",cancelAllTime);
                  }
 else {
                    orderItem.set("autoCancelDate",cancelDate);
                  }
                }
              }
              ordersToNotify.add(orderId);
            }
            toBeStored.add(orderItem);
          }
        }
        if (toBeStored.size() > 0) {
          try {
            delegator.storeAll(toBeStored);
          }
 catch (          GenericEntityException e) {
            Debug.logError(e,"Problem storing order items",module);
          }
        }
      }
    }
  }
  Iterator orderNotifyIter=ordersToNotify.iterator();
  while (orderNotifyIter.hasNext()) {
    String orderId=(String)orderNotifyIter.next();
    try {
      dispatcher.runAsync("sendOrderBackorderNotification",UtilMisc.toMap("orderId",orderId,"userLogin",userLogin));
    }
 catch (    GenericServiceException e) {
      Debug.logError(e,"Problems sending off the notification",module);
      continue;
    }
  }
  return ServiceUtil.returnSuccess();
}
