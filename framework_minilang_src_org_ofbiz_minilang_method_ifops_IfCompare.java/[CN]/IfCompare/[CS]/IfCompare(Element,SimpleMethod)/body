{
  super(element,simpleMethod);
  this.mapAcsr=new ContextAccessor<Map<String,? extends Object>>(element.getAttribute("map-name"));
  this.fieldAcsr=new ContextAccessor<Object>(element.getAttribute("field"));
  if (this.fieldAcsr.isEmpty()) {
    this.fieldAcsr=new ContextAccessor<Object>(element.getAttribute("field-name"));
  }
  this.value=element.getAttribute("value");
  this.operator=element.getAttribute("operator");
  this.compare=Compare.getInstance(this.operator);
  if (this.compare == null) {
    MiniLangValidate.handleError("Invalid operator " + this.operator,simpleMethod,element);
  }
  this.type=element.getAttribute("type");
  Class<?> targetClass=null;
  if (!this.type.isEmpty()) {
    if ("contains".equals(this.operator)) {
      MiniLangValidate.handleError("Operator \"contains\" does not support type conversions (remove the type attribute).",simpleMethod,element);
      targetClass=Object.class;
    }
 else {
      try {
        targetClass=ObjectType.loadClass(this.type);
      }
 catch (      ClassNotFoundException e) {
        MiniLangValidate.handleError("Invalid type " + this.type,simpleMethod,element);
      }
    }
  }
  this.targetClass=targetClass;
  this.format=element.getAttribute("format");
  this.subOps=Collections.unmodifiableList(SimpleMethod.readOperations(element,simpleMethod));
  Element elseElement=UtilXml.firstChildElement(element,"else");
  if (elseElement != null) {
    this.elseSubOps=Collections.unmodifiableList(SimpleMethod.readOperations(elseElement,simpleMethod));
  }
}
