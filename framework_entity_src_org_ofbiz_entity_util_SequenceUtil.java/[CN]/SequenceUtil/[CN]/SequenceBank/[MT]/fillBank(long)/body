{
  if ((curSeqId + stagger) <= maxSeqId)   return;
  long bankSize=SequenceUtil.this.bankSize;
  if (stagger > 1) {
    bankSize=stagger * defaultBankSize;
  }
  if (bankSize > maxBankSize)   bankSize=maxBankSize;
  long val1=0;
  long val2=0;
  int numTries=0;
  while (val1 + bankSize != val2) {
    if (Debug.verboseOn())     Debug.logVerbose("[SequenceUtil.SequenceBank.fillBank] Trying to get a bank of sequenced ids for " + this.seqName + "; start of loop val1="+ val1+ ", val2="+ val2+ ", bankSize="+ bankSize,module);
synchronized (this) {
      Transaction suspendedTransaction=null;
      try {
        suspendedTransaction=TransactionUtil.suspend();
        boolean beganTransaction=false;
        try {
          beganTransaction=TransactionUtil.begin();
          Connection connection=null;
          Statement stmt=null;
          ResultSet rs=null;
          try {
            connection=ConnectionFactory.getConnection(SequenceUtil.this.helperInfo);
          }
 catch (          SQLException sqle) {
            Debug.logWarning("[SequenceUtil.SequenceBank.fillBank]: Unable to esablish a connection with the database... Error was:" + sqle.toString(),module);
            throw sqle;
          }
catch (          GenericEntityException e) {
            Debug.logWarning("[SequenceUtil.SequenceBank.fillBank]: Unable to esablish a connection with the database... Error was: " + e.toString(),module);
            throw e;
          }
          if (connection == null) {
            throw new GenericEntityException("[SequenceUtil.SequenceBank.fillBank]: Unable to esablish a connection with the database, connection was null...");
          }
          String sql=null;
          try {
            stmt=connection.createStatement();
            if (clustered) {
              sql="SELECT " + SequenceUtil.this.idColName + " FROM "+ SequenceUtil.this.tableName+ " WHERE "+ SequenceUtil.this.nameColName+ "='"+ this.seqName+ "'"+ " FOR UPDATE";
            }
 else {
              sql="SELECT " + SequenceUtil.this.idColName + " FROM "+ SequenceUtil.this.tableName+ " WHERE "+ SequenceUtil.this.nameColName+ "='"+ this.seqName+ "'";
            }
            rs=stmt.executeQuery(sql);
            boolean gotVal1=false;
            if (rs.next()) {
              val1=rs.getLong(SequenceUtil.this.idColName);
              gotVal1=true;
            }
            rs.close();
            if (!gotVal1) {
              Debug.logWarning("[SequenceUtil.SequenceBank.fillBank] first select failed: will try to add new row, result set was empty for sequence [" + seqName + "] \nUsed SQL: "+ sql+ " \n Thread Name is: "+ Thread.currentThread().getName()+ ":"+ Thread.currentThread().toString(),module);
              sql="INSERT INTO " + SequenceUtil.this.tableName + " ("+ SequenceUtil.this.nameColName+ ", "+ SequenceUtil.this.idColName+ ") VALUES ('"+ this.seqName+ "', "+ startSeqId+ ")";
              if (stmt.executeUpdate(sql) <= 0) {
                throw new GenericEntityException("No rows changed when trying insert new sequence row with this SQL: " + sql);
              }
              continue;
            }
            sql="UPDATE " + SequenceUtil.this.tableName + " SET "+ SequenceUtil.this.idColName+ "="+ SequenceUtil.this.idColName+ "+"+ bankSize+ " WHERE "+ SequenceUtil.this.nameColName+ "='"+ this.seqName+ "'";
            if (stmt.executeUpdate(sql) <= 0) {
              throw new GenericEntityException("[SequenceUtil.SequenceBank.fillBank] update failed, no rows changes for seqName: " + seqName);
            }
            if (clustered) {
              sql="SELECT " + SequenceUtil.this.idColName + " FROM "+ SequenceUtil.this.tableName+ " WHERE "+ SequenceUtil.this.nameColName+ "='"+ this.seqName+ "'"+ " FOR UPDATE";
            }
 else {
              sql="SELECT " + SequenceUtil.this.idColName + " FROM "+ SequenceUtil.this.tableName+ " WHERE "+ SequenceUtil.this.nameColName+ "='"+ this.seqName+ "'";
            }
            rs=stmt.executeQuery(sql);
            boolean gotVal2=false;
            if (rs.next()) {
              val2=rs.getLong(SequenceUtil.this.idColName);
              gotVal2=true;
            }
            rs.close();
            if (!gotVal2) {
              throw new GenericEntityException("[SequenceUtil.SequenceBank.fillBank] second select failed: aborting, result set was empty for sequence: " + seqName);
            }
            if (val1 + bankSize != val2) {
              TransactionUtil.setRollbackOnly("Forcing transaction rollback in sequence increment because we didn't get a clean update, ie a conflict was found, so not saving the results",null);
            }
          }
 catch (          SQLException sqle) {
            Debug.logWarning(sqle,"[SequenceUtil.SequenceBank.fillBank] SQL Exception while executing the following:\n" + sql + "\nError was:"+ sqle.getMessage(),module);
            throw sqle;
          }
 finally {
            try {
              if (stmt != null)               stmt.close();
            }
 catch (            SQLException sqle) {
              Debug.logWarning(sqle,"Error closing statement in sequence util",module);
            }
            try {
              if (connection != null)               connection.close();
            }
 catch (            SQLException sqle) {
              Debug.logWarning(sqle,"Error closing connection in sequence util",module);
            }
          }
        }
 catch (        Exception e) {
          String errMsg="General error in getting a sequenced ID";
          Debug.logError(e,errMsg,module);
          try {
            TransactionUtil.rollback(beganTransaction,errMsg,e);
          }
 catch (          GenericTransactionException gte2) {
            Debug.logError(gte2,"Unable to rollback transaction",module);
          }
          break;
        }
 finally {
          try {
            TransactionUtil.commit(beganTransaction);
          }
 catch (          GenericTransactionException gte) {
            Debug.logError(gte,"Unable to commit sequence increment transaction, continuing anyway though",module);
          }
        }
      }
 catch (      GenericTransactionException e) {
        Debug.logError(e,"System Error suspending transaction in sequence util",module);
      }
 finally {
        if (suspendedTransaction != null) {
          try {
            TransactionUtil.resume(suspendedTransaction);
          }
 catch (          GenericTransactionException e) {
            Debug.logError(e,"Error resuming suspended transaction in sequence util",module);
          }
        }
      }
    }
    if (val1 + bankSize != val2) {
      if (numTries >= maxTries) {
        String errMsg="[SequenceUtil.SequenceBank.fillBank] maxTries (" + maxTries + ") reached for seqName ["+ this.seqName+ "], giving up.";
        Debug.logError(errMsg,module);
        return;
      }
      long waitTime=(long)(Math.random() * (maxWaitMillis - minWaitMillis) + minWaitMillis);
      Debug.logWarning("[SequenceUtil.SequenceBank.fillBank] Collision found for seqName [" + seqName + "], val1="+ val1+ ", val2="+ val2+ ", val1+bankSize="+ (val1 + bankSize)+ ", bankSize="+ bankSize+ ", waitTime="+ waitTime,module);
      try {
        java.lang.Thread.sleep(waitTime);
      }
 catch (      Exception e) {
        Debug.logWarning(e,"Error waiting in sequence util",module);
        return;
      }
    }
    numTries++;
  }
  curSeqId=val1;
  maxSeqId=val2;
  if (Debug.infoOn())   Debug.logInfo("Got bank of sequenced IDs for [" + this.seqName + "]; curSeqId="+ curSeqId+ ", maxSeqId="+ maxSeqId+ ", bankSize="+ bankSize,module);
}
