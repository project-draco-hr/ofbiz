{
  GenericDelegator delegator=(GenericDelegator)ctx.get("delegator");
  GenericValue parentContent=(GenericValue)currentNode.get("value");
  String contentAssocTypeId=(String)ctx.get("contentAssocTypeId");
  String contentTypeId=(String)ctx.get("contentTypeId");
  String mapKey=(String)ctx.get("mapKey");
  String parentContentId=(String)parentContent.get("contentId");
  Map whenMap=(Map)ctx.get("whenMap");
  List kids=new ArrayList();
  currentNode.put("kids",kids);
  String direction=(String)ctx.get("direction");
  if (UtilValidate.isEmpty(direction))   direction="From";
  Timestamp fromDate=(Timestamp)ctx.get("fromDate");
  Timestamp thruDate=(Timestamp)ctx.get("thruDate");
  List assocTypeList=StringUtil.split(contentAssocTypeId," ");
  List contentTypeList=StringUtil.split(contentTypeId," ");
  String contentAssocPredicateId=null;
  Boolean nullThruDatesOnly=new Boolean(true);
  Map results=null;
  try {
    results=ContentServicesComplex.getAssocAndContentAndDataResourceCacheMethod(delegator,parentContentId,mapKey,direction,null,null,assocTypeList,contentTypeList,nullThruDatesOnly,contentAssocPredicateId);
  }
 catch (  GenericEntityException e) {
    throw new RuntimeException(e.getMessage());
  }
catch (  MiniLangException e2) {
    throw new RuntimeException(e2.getMessage());
  }
  List relatedViews=(List)results.get("entityList");
  Iterator it=relatedViews.iterator();
  while (it.hasNext()) {
    GenericValue assocValue=(GenericValue)it.next();
    Map thisNode=ContentWorker.makeNode(assocValue);
    checkConditions(delegator,thisNode,null,whenMap);
    boolean isReturnBeforePick=booleanDataType(thisNode.get("isReturnBeforePick"));
    boolean isReturnAfterPick=booleanDataType(thisNode.get("isReturnAfterPick"));
    boolean isPick=booleanDataType(thisNode.get("isPick"));
    boolean isFollow=booleanDataType(thisNode.get("isFollow"));
    kids.add(thisNode);
    if (isPick) {
      Integer count=(Integer)currentNode.get("count");
      if (count == null) {
        count=new Integer(1);
      }
 else {
        count=new Integer(count.intValue() + 1);
      }
      currentNode.put("count",count);
    }
  }
}
