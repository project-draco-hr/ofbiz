{
  assertIsRunning();
  DispatchContext dctx=getDispatcher().getDispatchContext();
  if (dctx == null) {
    Debug.logError("Unable to locate DispatchContext object; not running job!",module);
    return null;
  }
  List<Job> poll=FastList.newInstance();
  List<EntityExpr> expressions=UtilMisc.toList(EntityCondition.makeCondition("runTime",EntityOperator.LESS_THAN_EQUAL_TO,UtilDateTime.nowTimestamp()),EntityCondition.makeCondition("startDateTime",EntityOperator.EQUALS,null),EntityCondition.makeCondition("cancelDateTime",EntityOperator.EQUALS,null),EntityCondition.makeCondition("runByInstanceId",EntityOperator.EQUALS,null));
  List<String> pools=ServiceConfigUtil.getRunPools();
  List<EntityExpr> poolsExpr=UtilMisc.toList(EntityCondition.makeCondition("poolId",EntityOperator.EQUALS,null));
  if (pools != null) {
    for (    String poolName : pools) {
      poolsExpr.add(EntityCondition.makeCondition("poolId",EntityOperator.EQUALS,poolName));
    }
  }
  EntityCondition baseCondition=EntityCondition.makeCondition(expressions);
  EntityCondition poolCondition=EntityCondition.makeCondition(poolsExpr,EntityOperator.OR);
  EntityCondition mainCondition=EntityCondition.makeCondition(UtilMisc.toList(baseCondition,poolCondition));
  EntityListIterator jobsIterator=null;
  boolean beganTransaction=false;
  try {
    beganTransaction=TransactionUtil.begin();
    if (!beganTransaction) {
      Debug.logError("Unable to poll JobSandbox for jobs; transaction was not started by this process",module);
      return null;
    }
    jobsIterator=delegator.find("JobSandbox",mainCondition,null,null,UtilMisc.toList("runTime"),null);
    GenericValue jobValue=jobsIterator.next();
    while (jobValue != null) {
      jobValue.putAll(updateFields);
      jobValue.store();
      poll.add(new PersistedServiceJob(dctx,jobValue,null));
      if (poll.size() == limit) {
        break;
      }
      jobValue=jobsIterator.next();
    }
  }
 catch (  Throwable t) {
    String errMsg="Error in polling JobSandbox: [" + t.toString() + "]. Rolling back transaction.";
    Debug.logError(t,errMsg,module);
    try {
      TransactionUtil.rollback(beganTransaction,errMsg,t);
    }
 catch (    GenericEntityException e2) {
      Debug.logError(e2,"[Delegator] Could not rollback transaction: " + e2.toString(),module);
    }
  }
 finally {
    if (jobsIterator != null) {
      try {
        jobsIterator.close();
      }
 catch (      GenericEntityException e) {
        Debug.logWarning(e,module);
      }
    }
    try {
      TransactionUtil.commit(beganTransaction);
    }
 catch (    GenericTransactionException e) {
      String errMsg="Transaction error trying to commit when polling and updating the JobSandbox: " + e.toString();
      Debug.logError(e,errMsg,module);
    }
  }
  return poll;
}
