{
  assertIsRunning();
  List<Job> poll=new ArrayList<Job>(limit);
  DispatchContext dctx=getDispatcher().getDispatchContext();
  if (dctx == null) {
    Debug.logWarning("Unable to locate DispatchContext object; not running job!",module);
    return poll;
  }
  List<EntityExpr> expressions=UtilMisc.toList(EntityCondition.makeCondition("runTime",EntityOperator.LESS_THAN_EQUAL_TO,UtilDateTime.nowTimestamp()),EntityCondition.makeCondition("startDateTime",EntityOperator.EQUALS,null),EntityCondition.makeCondition("cancelDateTime",EntityOperator.EQUALS,null),EntityCondition.makeCondition("runByInstanceId",EntityOperator.EQUALS,null));
  List<String> pools=null;
  try {
    pools=getRunPools();
  }
 catch (  GenericConfigException e) {
    Debug.logWarning(e,"Unable to get run pools - not running job: ",module);
    return poll;
  }
  List<EntityExpr> poolsExpr=UtilMisc.toList(EntityCondition.makeCondition("poolId",EntityOperator.EQUALS,null));
  if (!pools.isEmpty()) {
    for (    String poolName : pools) {
      poolsExpr.add(EntityCondition.makeCondition("poolId",EntityOperator.EQUALS,poolName));
    }
  }
  EntityCondition baseCondition=EntityCondition.makeCondition(expressions);
  EntityCondition poolCondition=EntityCondition.makeCondition(poolsExpr,EntityOperator.OR);
  EntityCondition mainCondition=EntityCondition.makeCondition(UtilMisc.toList(baseCondition,poolCondition));
  EntityListIterator jobsIterator=null;
  boolean beganTransaction=false;
  try {
    beganTransaction=TransactionUtil.begin();
    if (!beganTransaction) {
      Debug.logWarning("Unable to poll JobSandbox for jobs; transaction was not started by this process",module);
      return poll;
    }
    jobsIterator=delegator.find("JobSandbox",mainCondition,null,null,UtilMisc.toList("runTime"),null);
    GenericValue jobValue=jobsIterator.next();
    while (jobValue != null) {
      List<EntityExpr> updateExpression=UtilMisc.toList(EntityCondition.makeCondition("jobId",EntityOperator.EQUALS,jobValue.get("jobId")),EntityCondition.makeCondition("runByInstanceId",EntityOperator.EQUALS,null));
      int rowsUpdated=delegator.storeByCondition("JobSandbox",UtilMisc.toMap("runByInstanceId",instanceId),EntityCondition.makeCondition(updateExpression));
      if (rowsUpdated == 1) {
        poll.add(new PersistedServiceJob(dctx,jobValue,null));
        if (poll.size() == limit) {
          break;
        }
      }
      jobValue=jobsIterator.next();
    }
  }
 catch (  Throwable t) {
    poll.clear();
    String errMsg="Exception thrown while polling JobSandbox: ";
    Debug.logWarning(t,errMsg,module);
    try {
      TransactionUtil.rollback(beganTransaction,errMsg + t.getMessage(),t);
    }
 catch (    GenericEntityException e) {
      Debug.logWarning(e,"Exception thrown while rolling back transaction: ",module);
    }
  }
 finally {
    if (jobsIterator != null) {
      try {
        jobsIterator.close();
      }
 catch (      GenericEntityException e) {
        Debug.logWarning(e,module);
      }
    }
    try {
      TransactionUtil.commit(beganTransaction);
    }
 catch (    GenericTransactionException e) {
      Debug.logWarning(e,"Transaction error trying to commit when polling and updating the JobSandbox: ",module);
    }
  }
  if (poll.isEmpty()) {
    Calendar cal=Calendar.getInstance();
    try {
      int daysToKeep=ServiceConfigUtil.getServiceEngine().getThreadPool().getPurgeJobDays();
      cal.add(Calendar.DAY_OF_YEAR,-daysToKeep);
    }
 catch (    GenericConfigException e) {
      Debug.logWarning(e,"Unable to get purge job days: ",module);
      return poll;
    }
    Timestamp purgeTime=new Timestamp(cal.getTimeInMillis());
    List<EntityExpr> finExp=UtilMisc.toList(EntityCondition.makeCondition("finishDateTime",EntityOperator.NOT_EQUAL,null),EntityCondition.makeCondition("finishDateTime",EntityOperator.LESS_THAN,purgeTime));
    List<EntityExpr> canExp=UtilMisc.toList(EntityCondition.makeCondition("cancelDateTime",EntityOperator.NOT_EQUAL,null),EntityCondition.makeCondition("cancelDateTime",EntityOperator.LESS_THAN,purgeTime));
    EntityCondition doneCond=EntityCondition.makeCondition(UtilMisc.toList(EntityCondition.makeCondition(canExp),EntityCondition.makeCondition(finExp)),EntityOperator.OR);
    mainCondition=EntityCondition.makeCondition(UtilMisc.toList(EntityCondition.makeCondition("runByInstanceId",instanceId),doneCond));
    beganTransaction=false;
    jobsIterator=null;
    try {
      beganTransaction=TransactionUtil.begin();
      if (!beganTransaction) {
        Debug.logWarning("Unable to poll JobSandbox for jobs; transaction was not started by this process",module);
        return poll;
      }
      jobsIterator=delegator.find("JobSandbox",mainCondition,null,null,UtilMisc.toList("jobId"),null);
      GenericValue jobValue=jobsIterator.next();
      while (jobValue != null) {
        poll.add(new PurgeJob(jobValue));
        if (poll.size() == limit) {
          break;
        }
        jobValue=jobsIterator.next();
      }
    }
 catch (    Throwable t) {
      poll.clear();
      String errMsg="Exception thrown while polling JobSandbox: ";
      Debug.logWarning(t,errMsg,module);
      try {
        TransactionUtil.rollback(beganTransaction,errMsg + t.getMessage(),t);
      }
 catch (      GenericEntityException e) {
        Debug.logWarning(e,"Exception thrown while rolling back transaction: ",module);
      }
    }
 finally {
      if (jobsIterator != null) {
        try {
          jobsIterator.close();
        }
 catch (        GenericEntityException e) {
          Debug.logWarning(e,module);
        }
      }
      try {
        TransactionUtil.commit(beganTransaction);
      }
 catch (      GenericTransactionException e) {
        Debug.logWarning(e,"Transaction error trying to commit when polling the JobSandbox: ",module);
      }
    }
  }
  return poll;
}
