{
  List poll=FastList.newInstance();
  Collection<GenericValue> jobEnt=null;
  List<String> order=UtilMisc.toList("runTime");
  List<EntityExpr> expressions=UtilMisc.toList(new EntityExpr("runTime",EntityOperator.LESS_THAN_EQUAL_TO,UtilDateTime.nowTimestamp()),new EntityExpr("startDateTime",EntityOperator.EQUALS,null),new EntityExpr("cancelDateTime",EntityOperator.EQUALS,null),new EntityExpr("runByInstanceId",EntityOperator.EQUALS,null));
  List pools=ServiceConfigUtil.getRunPools();
  List<EntityExpr> poolsExpr=UtilMisc.toList(new EntityExpr("poolId",EntityOperator.EQUALS,null));
  if (pools != null) {
    Iterator poolsIter=pools.iterator();
    while (poolsIter.hasNext()) {
      String poolName=(String)poolsIter.next();
      poolsExpr.add(new EntityExpr("poolId",EntityOperator.EQUALS,poolName));
    }
  }
  EntityCondition baseCondition=new EntityConditionList<EntityExpr>(expressions,EntityOperator.AND);
  EntityCondition poolCondition=new EntityConditionList<EntityExpr>(poolsExpr,EntityOperator.OR);
  EntityCondition mainCondition=new EntityConditionList<EntityCondition>(UtilMisc.toList(baseCondition,poolCondition),EntityOperator.AND);
  boolean pollDone=false;
  while (!pollDone) {
    boolean beganTransaction=false;
    try {
      beganTransaction=TransactionUtil.begin();
      if (!beganTransaction) {
        Debug.logError("Unable to poll for jobs; transaction was not started by this process",module);
        return null;
      }
      List localPoll=FastList.newInstance();
      delegator.storeByCondition("JobSandbox",updateFields,mainCondition);
      jobEnt=delegator.findByAnd("JobSandbox",updateFields,order);
      if (jobEnt != null && jobEnt.size() > 0) {
        for (        GenericValue v : jobEnt) {
          DispatchContext dctx=getDispatcher().getDispatchContext();
          if (dctx == null) {
            Debug.logError("Unable to locate DispatchContext object; not running job!",module);
            continue;
          }
          Job job=new PersistedServiceJob(dctx,v,null);
          try {
            job.queue();
            localPoll.add(job);
          }
 catch (          InvalidJobException e) {
            Debug.logError(e,module);
          }
        }
      }
 else {
        pollDone=true;
      }
      poll.addAll(localPoll);
    }
 catch (    Throwable t) {
      String errMsg="Error in polling JobSandbox: [" + t.toString() + "]. Rolling back transaction.";
      Debug.logError(t,errMsg,module);
      try {
        TransactionUtil.rollback(beganTransaction,errMsg,t);
      }
 catch (      GenericEntityException e2) {
        Debug.logError(e2,"[GenericDelegator] Could not rollback transaction: " + e2.toString(),module);
      }
    }
 finally {
      try {
        TransactionUtil.commit(beganTransaction);
      }
 catch (      GenericTransactionException e) {
        String errMsg="Transaction error trying to commit when polling and updating the JobSandbox: " + e.toString();
        Debug.logError(e,errMsg,module);
      }
    }
  }
  return poll.iterator();
}
