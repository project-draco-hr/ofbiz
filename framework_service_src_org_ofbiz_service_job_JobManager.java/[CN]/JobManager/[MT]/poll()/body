{
  assertIsRunning();
  List<Job> poll=FastList.newInstance();
  List<String> order=UtilMisc.toList("runTime");
  List<EntityExpr> expressions=UtilMisc.toList(EntityCondition.makeCondition("runTime",EntityOperator.LESS_THAN_EQUAL_TO,UtilDateTime.nowTimestamp()),EntityCondition.makeCondition("startDateTime",EntityOperator.EQUALS,null),EntityCondition.makeCondition("cancelDateTime",EntityOperator.EQUALS,null),EntityCondition.makeCondition("runByInstanceId",EntityOperator.EQUALS,null));
  List<String> pools=ServiceConfigUtil.getRunPools();
  List<EntityExpr> poolsExpr=UtilMisc.toList(EntityCondition.makeCondition("poolId",EntityOperator.EQUALS,null));
  if (pools != null) {
    for (    String poolName : pools) {
      poolsExpr.add(EntityCondition.makeCondition("poolId",EntityOperator.EQUALS,poolName));
    }
  }
  EntityCondition baseCondition=EntityCondition.makeCondition(expressions);
  EntityCondition poolCondition=EntityCondition.makeCondition(poolsExpr,EntityOperator.OR);
  EntityCondition mainCondition=EntityCondition.makeCondition(UtilMisc.toList(baseCondition,poolCondition));
  boolean pollDone=false;
  while (!pollDone) {
    boolean beganTransaction=false;
    try {
      beganTransaction=TransactionUtil.begin();
      if (!beganTransaction) {
        Debug.logError("Unable to poll for jobs; transaction was not started by this process",module);
        return null;
      }
      List<Job> localPoll=FastList.newInstance();
      delegator.storeByCondition("JobSandbox",updateFields,mainCondition);
      List<GenericValue> jobEnt=delegator.findByAnd("JobSandbox",updateFields,order,false);
      if (UtilValidate.isNotEmpty(jobEnt)) {
        for (        GenericValue v : jobEnt) {
          DispatchContext dctx=getDispatcher().getDispatchContext();
          if (dctx == null) {
            Debug.logError("Unable to locate DispatchContext object; not running job!",module);
            continue;
          }
          Job job=new PersistedServiceJob(dctx,v,null);
          try {
            job.queue();
            localPoll.add(job);
          }
 catch (          InvalidJobException e) {
            Debug.logError(e,module);
          }
        }
      }
 else {
        pollDone=true;
      }
      poll.addAll(localPoll);
    }
 catch (    Throwable t) {
      String errMsg="Error in polling JobSandbox: [" + t.toString() + "]. Rolling back transaction.";
      Debug.logError(t,errMsg,module);
      try {
        TransactionUtil.rollback(beganTransaction,errMsg,t);
      }
 catch (      GenericEntityException e2) {
        Debug.logError(e2,"[Delegator] Could not rollback transaction: " + e2.toString(),module);
      }
    }
 finally {
      try {
        TransactionUtil.commit(beganTransaction);
      }
 catch (      GenericTransactionException e) {
        String errMsg="Transaction error trying to commit when polling and updating the JobSandbox: " + e.toString();
        Debug.logError(e,errMsg,module);
      }
    }
  }
  return poll;
}
