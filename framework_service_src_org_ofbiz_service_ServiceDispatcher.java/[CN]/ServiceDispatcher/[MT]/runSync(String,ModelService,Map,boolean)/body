{
  long serviceStartTime=System.currentTimeMillis();
  boolean debugging=checkDebug(modelService,1,true);
  if (Debug.verboseOn()) {
    Debug.logVerbose("[ServiceDispatcher.runSync] : invoking service " + modelService.name + " ["+ modelService.location+ "/"+ modelService.invoke+ "] ("+ modelService.engineName+ ")",module);
  }
  if (context == null) {
    context=FastMap.newInstance();
  }
  Map result=FastMap.newInstance();
  boolean isFailure=false;
  boolean isError=false;
  RunningService rs=this.logService(localName,modelService,GenericEngine.SYNC_MODE);
  Map eventMap=ServiceEcaUtil.getServiceEventMap(modelService.name);
  Locale locale=this.checkLocale(context);
  DispatchContext ctx=(DispatchContext)localContext.get(localName);
  GenericEngine engine=this.getGenericEngine(modelService.engineName);
  modelService.updateDefaultValues(context,ModelService.IN_PARAM);
  Map ecaContext=null;
  Transaction parentTransaction=null;
  boolean beganTrans=false;
  try {
    if (modelService.useTransaction) {
      beganTrans=TransactionUtil.begin(modelService.transactionTimeout);
      if (modelService.requireNewTransaction && !beganTrans) {
        parentTransaction=TransactionUtil.suspend();
        beganTrans=TransactionUtil.begin(modelService.transactionTimeout);
      }
    }
    if (beganTrans && TransactionUtil.debugResources) {
      DebugXaResource dxa=new DebugXaResource(modelService.name);
      try {
        dxa.enlist();
      }
 catch (      Exception e) {
        Debug.logError(e,module);
      }
    }
    try {
      if (eventMap != null)       ServiceEcaUtil.evalRules(modelService.name,eventMap,"global-rollback",ctx,context,result,false,false);
      if (eventMap != null)       ServiceEcaUtil.evalRules(modelService.name,eventMap,"global-commit",ctx,context,result,false,false);
      if (eventMap != null)       ServiceEcaUtil.evalRules(modelService.name,eventMap,"auth",ctx,context,result,false,false);
      context=checkAuth(localName,context,modelService);
      Object userLogin=context.get("userLogin");
      if (modelService.auth && userLogin == null) {
        throw new ServiceAuthException("User authorization is required for this service: " + modelService.name + modelService.debugInfo());
      }
      if (eventMap != null)       ServiceEcaUtil.evalRules(modelService.name,eventMap,"in-validate",ctx,context,result,false,false);
      isFailure=ServiceUtil.isFailure(result);
      isError=ServiceUtil.isError(result);
      if (modelService.validate && !isError && !isFailure) {
        try {
          modelService.validate(context,ModelService.IN_PARAM,locale);
        }
 catch (        ServiceValidationException e) {
          Debug.logError(e,"Incoming context (in runSync : " + modelService.name + ") does not match expected requirements",module);
          throw e;
        }
      }
      if (eventMap != null)       ServiceEcaUtil.evalRules(modelService.name,eventMap,"invoke",ctx,context,result,false,false);
      isFailure=ServiceUtil.isFailure(result);
      isError=ServiceUtil.isError(result);
      if (!isError && !isFailure) {
        Map invokeResult=engine.runSync(localName,modelService,context);
        engine.sendCallbacks(modelService,context,invokeResult,GenericEngine.SYNC_MODE);
        if (invokeResult != null) {
          result.putAll(invokeResult);
        }
 else {
          Debug.logWarning("Service (in runSync : " + modelService.name + ") returns null result",module);
        }
      }
      isFailure=ServiceUtil.isFailure(result);
      isError=ServiceUtil.isError(result);
      ecaContext=FastMap.newInstance();
      ecaContext.putAll(context);
      ecaContext.putAll(result);
      modelService.updateDefaultValues(context,ModelService.OUT_PARAM);
      if (modelService.validate && validateOut) {
        if (eventMap != null)         ServiceEcaUtil.evalRules(modelService.name,eventMap,"out-validate",ctx,ecaContext,result,isError,isFailure);
        try {
          modelService.validate(result,ModelService.OUT_PARAM,locale);
        }
 catch (        ServiceValidationException e) {
          Debug.logError(e,"Outgoing result (in runSync : " + modelService.name + ") does not match expected requirements",module);
          throw e;
        }
      }
      if (eventMap != null)       ServiceEcaUtil.evalRules(modelService.name,eventMap,"commit",ctx,ecaContext,result,isError,isFailure);
      isFailure=ServiceUtil.isFailure(result);
      isError=ServiceUtil.isError(result);
      if (isFailure) {
        Debug.logWarning("Service Failure [" + modelService.name + "]: "+ ServiceUtil.getErrorMessage(result),module);
      }
    }
 catch (    Throwable t) {
      if (Debug.timingOn()) {
        UtilTimer.closeTimer(localName + " / " + modelService.name,"Sync service failed...",module);
      }
      String errMsg="Service [" + modelService.name + "] threw an unexpected exception/error";
      Debug.logError(t,errMsg,module);
      engine.sendCallbacks(modelService,context,t,GenericEngine.SYNC_MODE);
      try {
        TransactionUtil.rollback(beganTrans,errMsg,t);
      }
 catch (      GenericTransactionException te) {
        Debug.logError(te,"Cannot rollback transaction",module);
      }
      checkDebug(modelService,0,debugging);
      rs.setEndStamp();
      if (t instanceof ServiceAuthException) {
        throw (ServiceAuthException)t;
      }
 else       if (t instanceof ServiceValidationException) {
        throw (ServiceValidationException)t;
      }
 else       if (t instanceof GenericServiceException) {
        throw (GenericServiceException)t;
      }
 else {
        throw new GenericServiceException("Service [" + modelService.name + "] Failed"+ modelService.debugInfo(),t);
      }
    }
 finally {
      if (isError) {
        String errMsg="Service Error [" + modelService.name + "]: "+ ServiceUtil.getErrorMessage(result);
        Debug.logError(errMsg,module);
        try {
          TransactionUtil.rollback(beganTrans,errMsg,null);
        }
 catch (        GenericTransactionException e) {
          Debug.logError(e,"Could not rollback transaction: " + e.toString(),module);
        }
      }
 else {
        try {
          TransactionUtil.commit(beganTrans);
        }
 catch (        GenericTransactionException e) {
          String errMsg="Could not commit transaction for service [" + modelService.name + "] call";
          Debug.logError(e,errMsg,module);
          if (e.getMessage() != null) {
            errMsg=errMsg + ": " + e.getMessage();
          }
          throw new GenericServiceException(errMsg);
        }
      }
      modelService.evalNotifications(this.getLocalContext(localName),context,result);
    }
  }
 catch (  GenericTransactionException te) {
    Debug.logError(te,"Problems with the transaction",module);
    throw new GenericServiceException("Problems with the transaction.",te.getNested());
  }
 finally {
    if (parentTransaction != null) {
      try {
        TransactionUtil.resume(parentTransaction);
      }
 catch (      GenericTransactionException ite) {
        Debug.logWarning(ite,"Transaction error, not resumed",module);
        throw new GenericServiceException("Resume transaction exception, see logs");
      }
    }
  }
  if (eventMap != null)   ServiceEcaUtil.evalRules(modelService.name,eventMap,"return",ctx,ecaContext,result,isError,isFailure);
  checkDebug(modelService,0,debugging);
  rs.setEndStamp();
  long timeToRun=System.currentTimeMillis() - serviceStartTime;
  if (Debug.timingOn() && timeToRun > 50) {
    Debug.logTiming("Sync service [" + localName + "/"+ modelService.name+ "] finished in ["+ timeToRun+ "] milliseconds",module);
  }
 else   if (timeToRun > 200) {
    Debug.logInfo("Sync service [" + localName + "/"+ modelService.name+ "] finished in ["+ timeToRun+ "] milliseconds",module);
  }
  return result;
}
